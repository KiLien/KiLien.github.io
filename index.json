[{"categories":["GitHub"],"content":"GitHub Profile README 介绍 最近，GitHub 上线了一个全新的个人页功能，可以显示一个自定义的 README.MD 在个人主页。 效果如下： 要激活此功能，需要新建一个与自己 ID 同名的 Repository，新 Repo 里的 README.MD 将出现在你的首页。 hayschan/hayschan is a special repository. Its README.md will appear on your public profile! hayschan/hayschan 是一个特殊的库。 它的 README.md 将出现在您的公开资料中！ ","date":"2021-04-03","objectID":"/github-profile-readme/:1:0","tags":["GitHub","README"],"title":"GitHub-profile-README：打造自己的个人主页","uri":"/github-profile-readme/"},{"categories":["GitHub"],"content":"如何创造自己的 README.MD ","date":"2021-04-03","objectID":"/github-profile-readme/:2:0","tags":["GitHub","README"],"title":"GitHub-profile-README：打造自己的个人主页","uri":"/github-profile-readme/"},{"categories":["GitHub"],"content":"1. 创建 Repository 创建新的 Repository，仓库名为自己的用户名，形如 仓库名/用户名 -\u003e hayschan/hayschan ","date":"2021-04-03","objectID":"/github-profile-readme/:2:1","tags":["GitHub","README"],"title":"GitHub-profile-README：打造自己的个人主页","uri":"/github-profile-readme/"},{"categories":["GitHub"],"content":"2.修改 README.md 修改你的 README.md，可以简简单单介绍下自己，或者加上一些好玩的功能（这步使用 markdown 语言） 这是我的 README文件，可以作为参考。 ","date":"2021-04-03","objectID":"/github-profile-readme/:2:2","tags":["GitHub","README"],"title":"GitHub-profile-README：打造自己的个人主页","uri":"/github-profile-readme/"},{"categories":["GitHub"],"content":"有趣的项目 下面我介绍下制作主页过程中遇到的一些有趣的项目： ","date":"2021-04-03","objectID":"/github-profile-readme/:3:0","tags":["GitHub","README"],"title":"GitHub-profile-README：打造自己的个人主页","uri":"/github-profile-readme/"},{"categories":["GitHub"],"content":"GitHub Profile README Generator GitHub Profile README Generator Github Readme Generator 这两个项目可以帮你轻松创建 GitHub Readme 文件，你可以直接复制/粘贴到你自己的 README 文件。 你可以加入诸如标题、字幕、技能、横幅图片、附加信息、社交媒体链接、徽章和GitHub统计等内容。 ","date":"2021-04-03","objectID":"/github-profile-readme/:3:1","tags":["GitHub","README"],"title":"GitHub-profile-README：打造自己的个人主页","uri":"/github-profile-readme/"},{"categories":["GitHub"],"content":"GitHub Readme Stats 在你的 README 中动态生成的 GitHub 统计信息 初级设置 用法很简单，将这行代码复制到你的 markdown 文件中，更改 ?username= 的值为你的 GitHub 用户名。 [![Anurag's GitHub stats](https://github-readme-stats.vercel.app/api?username=anuraghazra)](https://github.com/anuraghazra/github-readme-stats) 将私人项目贡献添加到总提交计数中 你可以使用参数 ?count_private=true 把私人贡献计数添加到总提交计数中。 注：如果你是自己部署本项目，私人贡献将会默认被计数，如果不是自己部署，你需要分享你的私人贡献计数。 选项: \u0026count_private=true ![Anurag's GitHub stats](https://github-readme-stats.vercel.app/api?username=anuraghazra\u0026count_private=true) 主题 你可以通过现有的主题进行卡片个性化，省去手动自定义的麻烦。 通过调用 ?theme=THEME_NAME 参数，像这样： ![Anurag's GitHub stats](https://github-readme-stats.vercel.app/api?username=anuraghazra\u0026show_icons=true\u0026theme=radical) 所有现有主题 dark, radical, merko, gruvbox, tokyonight, onedark, cobalt, synthwave, highcontrast, dracula 预览主题 你可以预览所有可用主题或者签出主题配置文件, 而且如果你喜欢, 你也可以贡献新的主题 :D ","date":"2021-04-03","objectID":"/github-profile-readme/:3:2","tags":["GitHub","README"],"title":"GitHub-profile-README：打造自己的个人主页","uri":"/github-profile-readme/"},{"categories":["GitHub"],"content":"Blog post workflow 这个项目可以使用 Github Action 自动抓取 RSS 源的最新文章或者 StackOverflow 活动显示在个人主页。 使用方法 在你的 README 文件中添加以下部分，你可以给任何你想要的标题。 只要你在 README 文件中使用\u003c！– BLOG-POST-LIST:START –\u003e\u003c！– BLOG-POST-LIST:END –\u003e。Github Action 会用实际的博文列表来替换这个标签。 # Blog posts \u003c!-- BLOG-POST-LIST:START --\u003e \u003c!-- BLOG-POST-LIST:END --\u003e 创建Github Action，爬取内容。 在工作流文件夹内创建一个名为blog-post-workflow.yml的新文件，内容如下。 name: Latest blog post workflow on: schedule: # Run workflow automatically - cron: '0 * * * *' # Runs every hour, on the hour workflow_dispatch: # Run workflow manually (without waiting for the cron to be called), through the Github Actions Workflow page directly jobs: update-readme-with-blog: name: Update this repo's README with latest blog posts runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - uses: gautamkrishnar/blog-post-workflow@master with: feed_list: \"https://KiLien.github.io/index.xml\" 用你自己的rss feed urls替换上面的url列表。 提交并等待它自动运行，或者你也可以手动触发它以立即看到结果。 类似项目 GitHub Readme LinkedIn 更新 Linked 到 README github-readme-twitter 更新最近一条 Twitter 动态 GitHub Readme Medium 更新最近的 Medium 文章 ","date":"2021-04-03","objectID":"/github-profile-readme/:3:3","tags":["GitHub","README"],"title":"GitHub-profile-README：打造自己的个人主页","uri":"/github-profile-readme/"},{"categories":["GitHub"],"content":"项目引用 GitHub README profile views counter Github Readme Quotes storyset Blog post workflow GitHub Readme Stats Github Readme Streak Stats ","date":"2021-04-03","objectID":"/github-profile-readme/:4:0","tags":["GitHub","README"],"title":"GitHub-profile-README：打造自己的个人主页","uri":"/github-profile-readme/"},{"categories":["GitHub"],"content":"PicGo 介绍 这是一款图片上传的工具，目前支持 SM.MS 图床，微博图床，七牛图床，腾讯云 COS，阿里云 OSS，Imgur，又拍云，GitHub等图床，未来将支持更多图床。 解决问题的思路就是，将本地的文件，或者剪切板上面的截图发送图床，然后生成在线图片的链接，这样就可以让Markdown文档飞起来了，走到哪就可以用到哪😊。 在众多的图床中，我选择的是GitHub图床，这可拓展定制。 创建自己的 GitHub 图床 ","date":"2021-04-02","objectID":"/githubPhotoBed/:1:0","tags":["图床","GitHub","PicGo"],"title":"PicGo+GitHub：打造自己的图床","uri":"/githubPhotoBed/"},{"categories":["GitHub"],"content":"1. 创建 GitHub 图床之前，需要注册 / 登陆 GitHub 账号 ","date":"2021-04-02","objectID":"/githubPhotoBed/:1:1","tags":["图床","GitHub","PicGo"],"title":"PicGo+GitHub：打造自己的图床","uri":"/githubPhotoBed/"},{"categories":["GitHub"],"content":"2. 创建 Repository 点击\"New repository\"按钮 第 4 步，repository 初始化 README 文件,可选 .gitignore 添加忽略文件夹，可选 选择开源协议，可选 ","date":"2021-04-02","objectID":"/githubPhotoBed/:1:2","tags":["图床","GitHub","PicGo"],"title":"PicGo+GitHub：打造自己的图床","uri":"/githubPhotoBed/"},{"categories":["GitHub"],"content":"3. 生成一个 Token 用于操作 GitHub repository 回到主页，点击\"Settings\"按钮 进入页面后，点击 \"Developer settings\" 按钮 点击 \"Personal access tokens\" 按钮 创建新的 Token 填写描述，选择\"repo\"权限，然后点击\"Generate token\",至少选择 repo 该项 注：创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候，可以建个文本文件好好保存，忘记了只有重新生成，每次都不一样。 ","date":"2021-04-02","objectID":"/githubPhotoBed/:1:3","tags":["图床","GitHub","PicGo"],"title":"PicGo+GitHub：打造自己的图床","uri":"/githubPhotoBed/"},{"categories":["GitHub"],"content":"GitHub Github在图床里，毫无疑问是扮演一个“仓库”的角色。 现在复习下步骤： 在自己的个人账户的settings里，找到左侧最下方的Developer settings。找到Personal access tokens。在右侧点击Generate new token。 这里名字可以随便写，后面的范围把repo勾选即可。记下来生成好的token。这一步的目的是生成一个能代表你身份的token， 然后交给picgo，使得它能替你上传图片，不用繁琐地再通过git commit 操作。 在你的这个仓库里，点击 releases。接着点击旁边的Draft New Release，最后点Publish release。这一步是发布一个版本的意思，我们的 jsDelivr 会用到它。 jsDelivr 这是一个用于 cdn 加速的服务，神奇的地方在于，你不需要对它配置任何东西——对照，我们直接进入vs picgo ","date":"2021-04-02","objectID":"/githubPhotoBed/:2:0","tags":["图床","GitHub","PicGo"],"title":"PicGo+GitHub：打造自己的图床","uri":"/githubPhotoBed/"},{"categories":["GitHub"],"content":"PicGo 这本身是一个方便图床上传的GUI工具，但是我这里推荐使用它的vs code 插件版本。 在VS Code 当中，搜索PicGo插件并安装。 打开VS Code的设置界面，搜索picGo。 只需要把 current 这里的下拉选项改为 github 把 Github:branch 这里改成 master 把 Github: Custom Url 这里改成使用 jsDelivr 分发的仓库地址。即https://cdn.jsdelivr.net/gh/你的github用户名/刚刚建的仓库名，这样子我们以后访问图片就可以加快啦！ 把 Github: Repo 改为 github用户名/仓库名 把 Github: Token 改为刚刚在 Github 记录下来的 token ","date":"2021-04-02","objectID":"/githubPhotoBed/:2:1","tags":["图床","GitHub","PicGo"],"title":"PicGo+GitHub：打造自己的图床","uri":"/githubPhotoBed/"},{"categories":["GitHub"],"content":"配置 PicGo ","date":"2021-04-02","objectID":"/githubPhotoBed/:3:0","tags":["图床","GitHub","PicGo"],"title":"PicGo+GitHub：打造自己的图床","uri":"/githubPhotoBed/"},{"categories":["GitHub"],"content":"1. 下载运行 PicGo。 macOS用户请下载最新版本的dmg文件，windows用户请下载最新版本的exe文件，linux用户请下载AppImage文件。 AppImage文件如何使用？»» 传送门 ","date":"2021-04-02","objectID":"/githubPhotoBed/:3:1","tags":["图床","GitHub","PicGo"],"title":"PicGo+GitHub：打造自己的图床","uri":"/githubPhotoBed/"},{"categories":["GitHub"],"content":"2. 配置图床 之后按照这个配置格式配置即可！ 设定仓库名的时候，按照 “账户名 / 仓库名“ 的格式填写 分支名统一填写master 将之前的Token黏贴在这里 存储的路径可以按照我这样子写，就会在repository下创建一个“xxx/xxx/xxxxx/”文件夹，当然你可以自己定义你的文件夹名字。 自定义域名的作用是在上传图片后成功后，PicGo会将 “自定义域名 + 上传的图片名” 生成的访问链接，放到剪切板上 https://cdn.jsdelivr.net/gh/ 用户名 / RepositoryName / 分支名，自定义域名需要按照这样去填写 ","date":"2021-04-02","objectID":"/githubPhotoBed/:3:2","tags":["图床","GitHub","PicGo"],"title":"PicGo+GitHub：打造自己的图床","uri":"/githubPhotoBed/"},{"categories":["GitHub"],"content":"3. 快捷键及相关配置 支持快捷键command+shift+p（macOS）或者control+shift+p（windows\\linux）用以支持快捷上传剪贴板里的图片（第一张）。 PicGo支持自定义快捷键，使用方法见配置手册。 注：可以将快捷键设置为 ctrl+shift+c ","date":"2021-04-02","objectID":"/githubPhotoBed/:3:3","tags":["图床","GitHub","PicGo"],"title":"PicGo+GitHub：打造自己的图床","uri":"/githubPhotoBed/"},{"categories":["GitHub"],"content":"4. 其他相关 vs-picgo：picgo的VSCode版。 ","date":"2021-04-02","objectID":"/githubPhotoBed/:3:4","tags":["图床","GitHub","PicGo"],"title":"PicGo+GitHub：打造自己的图床","uri":"/githubPhotoBed/"},{"categories":["GitHub"],"content":"总结 将上面的步骤都设置好之后，就可以让自己的Markdown文档飞起来了，每次截图之后，都可以按一下ctrl+shift+c，这样就会将剪切板上面的截图转化为在线网络图片链接，简直就是爽的不要不要的！！ 应用开发进度可以查看 Projects，会同步更新开发进度。 ","date":"2021-04-02","objectID":"/githubPhotoBed/:4:0","tags":["图床","GitHub","PicGo"],"title":"PicGo+GitHub：打造自己的图床","uri":"/githubPhotoBed/"},{"categories":["Algorithm"],"content":"LeetCode-160相交链表 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表**：** 相交链表\" 相交链表 在节点 c1 开始相交。 示例： 示例\" 示例 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 ","date":"2020-11-10","objectID":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-160-相交链表","uri":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"},{"categories":["Algorithm"],"content":"思路 指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历 如果 pA 到了末尾，则 pA = headB 继续遍历 如果 pB 到了末尾，则 pB = headA 继续遍历 如果较长的链表指针指向较短链表head时，长度差就消除了 只需要将最短链表遍历两次即可找到位置 A = a + c(公共部分) B = b +c(公共部分) 将 A B 相连 pA = A + B = (a + c + b) + c pB = B + A = (b + c + a) + c 如果 A B 有交点, 刚好在 c 开始时相遇 ","date":"2020-11-10","objectID":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/:1:0","tags":["算法","Leetcode"],"title":"LeetCode-160-相交链表","uri":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"},{"categories":["Algorithm"],"content":"代码 class Solution(object): def getIntersectionNode(self, headA, headB): “”” :type head1, head1: ListNode :rtype: ListNode “”” if not headA or not headB: return None pa = headA pb = headB while pa is not pb: pa = headB if pa is None else pa.next pb = headA if pb is None else pb.next return pa ","date":"2020-11-10","objectID":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/:2:0","tags":["算法","Leetcode"],"title":"LeetCode-160-相交链表","uri":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"},{"categories":["Algorithm"],"content":"复杂度 ","date":"2020-11-10","objectID":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/:3:0","tags":["算法","Leetcode"],"title":"LeetCode-160-相交链表","uri":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"},{"categories":["Algorithm"],"content":"时间：O(n) ","date":"2020-11-10","objectID":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/:3:1","tags":["算法","Leetcode"],"title":"LeetCode-160-相交链表","uri":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"},{"categories":["Algorithm"],"content":"空间：O(1) ","date":"2020-11-10","objectID":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/:3:2","tags":["算法","Leetcode"],"title":"LeetCode-160-相交链表","uri":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"},{"categories":["Python"],"content":"35个高级Python知识点总结 ","date":"2020-11-09","objectID":"/PythonTrick2/:0:0","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.1 一切皆对象 众所周知，Java中强调“一切皆对象”，但是Python中的面向对象比Java更加彻底，因为Python中的类(class)也是对象，函数（function）也是对象，而且Python的代码和模块也都是对象。 Python中函数和类可以赋值给一个变量 Python中函数和类可以存放到集合对象中 Python中函数和类可以作为一个函数的参数传递给函数 Python中函数和类可以作为返回值 Step.1 # 首先创建一个函数和一个Python3.x的新式类 class Demo(object): def __init__(self): print(\"Demo Class\") # 定义一个函数 def function(): print(\"function\") # 在Python无论是函数，还是类，都是对象，他们可以赋值给一个变量 class_value = Demo func_value = function # 并且可以通过变量调用 class_value() # Demo Class func_value() # function Step.2 # 将函数和类添加到集合中 obj_list = [] obj_list.append(Demo) obj_list.append(function) # 遍历列表 for i in obj_list: print(i) # \u003cclass '__main__.Demo'\u003e # \u003cfunction function at 0x0000020D681B3E18\u003e Step.3 # 定义一个具体函数 def test_func(class_name, func_name): class_name() func_name() # 将类名和函数名传入形参列表 test_func(Demo, function) # Demo Class # function Step.4 # 定义函数实现返回类和函数 def test_func2(): return Demo def test_func3(): return function # 执行函数 test_func2()() # Demo Class test_func3()() # function ","date":"2020-11-09","objectID":"/PythonTrick2/:0:1","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.2 关键字type、object、class之间的关系 在Python中， object 的实例是 type ， object 是顶层类，没有基类； type 的实例是 type ， type 的基类是 object 。Python中的内置类型的基类是 object ，但是他们都是由 type 实例化而来，具体的值由内置类型实例化而来。在Python2.x的语法中用户自定义的类没有明确指定基类就默认是没有基类，在Python3.x的语法中，指定基类为 object 。 # object是谁实例化的？ print(type(object)) # \u003cclass 'type'\u003e # object继承自哪个类？ print(object.__bases__) # () # type是谁实例化的？ print(type(type)) # \u003cclass 'type'\u003e # type继承自哪个类？ print(type.__bases__) # (\u003cclass 'object'\u003e,) # 定义一个变量 value = 100 # 100由谁实例化？ print(type(value)) # \u003cclass 'int'\u003e # int由谁实例化？ print(type(int)) # \u003cclass 'type'\u003e # int继承自哪个类？ print(int.__bases__) # (\u003cclass 'object'\u003e,) # Python 2.x的旧式类 class OldClass(): pass # Python 3.x的新式类 class NewClass(object): pass ","date":"2020-11-09","objectID":"/PythonTrick2/:0:2","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.3 Python的内置类型 在Python中，对象有3个特征属性： 在内存中的地址，使用 id() 函数进行查看 对象的类型 对象的默认值 Step.1 None类型 在Python解释器启动时，会创建一个None类型的None对象，并且None对象全局只有一个。 Step.2 数值类型 ini类型 float类型 complex类型 bool类型 Step.3 迭代类型 在Python中，迭代类型可以使用循环来进行遍历。 Step.4 序列类型 list tuple str array range bytes, bytearray, memoryvie（二进制序列） Step.5 映射类型 dict Step.6 集合类型 set frozenset Step.7 上下文管理类型 with语句 Step.8 其他类型 模块 class 实例 函数 方法 代码 object对象 type对象 ellipsis（省略号） notimplemented ","date":"2020-11-09","objectID":"/PythonTrick2/:0:3","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"NO.4 魔法函数 Python中的魔法函数使用双下划线开始，以双下划线结尾。关于详细介绍请看我的文章——《全面总结Python中的魔法函数》。 ","date":"2020-11-09","objectID":"/PythonTrick2/:0:4","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.5 鸭子类型与白鹅类型 鸭子类型是程序设计中的推断风格，在鸭子类型中关注对象如何使用而不是类型本身。鸭子类型像多态一样工作但是没有继承。鸭子类型的概念来自于：“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” # 定义狗类 class Dog(object): def eat(self): print(\"dog is eatting...\") # 定义猫类 class Cat(object): def eat(self): print(\"cat is eatting...\") # 定义鸭子类 class Duck(object): def eat(self): print(\"duck is eatting...\") # 以上Python中多态的体现 # 定义动物列表 an_li = [] # 将动物添加到列表 an_li.append(Dog) an_li.append(Cat) an_li.append(Duck) # 依次调用每个动物的eat()方法 for i in an_li: i().eat() # dog is eatting... # cat is eatting... # duck is eatting... 白鹅类型是指只要 cls 是抽象基类，即 cls 的元类是 abc.ABCMeta ，就可以使用 isinstance(obj, cls) 。 ","date":"2020-11-09","objectID":"/PythonTrick2/:0:5","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.6 协议、 抽象基类、abc模块和序列之间的继承关系 协议：Python中的非正式接口，是允许Python实现多态的方式，协议是非正式的，不具备强制性，由约定和文档定义。 接口：泛指实体把自己提供给外界的一种抽象化物（可以为另一实体），用以由内部操作分离出外部沟通方法，使其能被内部修改而不影响外界其他实体与其交互的方式。 我们可以使用 猴子补丁 来实现协议，那么什么是猴子补丁呢？ 猴子补丁就是在运行时修改模块或类，不去修改源代码，从而实现目标协议接口操作，这就是所谓的打猴子补丁。 Tips：猴子补丁的叫法起源于Zope框架，开发人员在修改Zope的Bug时，经常在程序后面追加更新的部分，这些 杂牌军补丁 的英文名字叫做 guerilla patch ，后来写成 gorllia ，接着就变成了 monkey 。 猴子补丁的主要作用是： 在运行时替换方法、属性 在不修改源代码的情况下对程序本身添加之前没有的功能 在运行时对象中添加补丁，而不是在磁盘中的源代码上 应用案例：假设写了一个很大的项目，处处使用了json模块来解析json文件，但是后来发现ujson比json性能更高，修改源代码是要修改很多处的，所以只需要在程序入口加入： import json # pip install ujson import ujson def monkey_patch_json(): json.__name__ = 'ujson' json.dumps = ujson.dumps json.loads = ujson.loads monkey_patch_json() Python 的抽象基类有一个重要实用优势：可以使用 register 类方法在终端用户的代码中把某个类 “声明” 为一个抽象基类的 “虚拟” 子 类（为此，被注册的类必腨满足抽象其类对方法名称和签名的要求，最重要的是要满足底 层语义契约；但是，开发那个类时不用了解抽象基类，更不用继承抽象基类 。有时，为了让抽象类识别子类，甚至不用注册。要抑制住创建抽象基类的冲动。滥用抽象基类会造成灾难性后果，表明语言太注重表面形式 。 抽象基类不能被实例化(不能创建对象)，通常是作为基类供子类继承，子类中重写虚函数，实现具体的接口。 判定某个对象的类型 强制子类必须实现某些方法 抽象基类的定义与使用 import abc # 定义缓存类 class Cache(metaclass=abc.ABCMeta): @abc.abstractmethod def get(self, key): pass @abc.abstractmethod def set(self, key, value): pass # 定义redis缓存类实现Cache类中的get()和set()方法 class RedisCache(Cache): def set(self, key): pass def get(self, key, value): pass 值得注意的是：Python 3.0-Python3.3之间，继承抽象基类的语法是 class ClassName(metaclass=adc.ABCMeta) ，其他版本是： class ClassName(abc.ABC) 。 collections.abc模块中各个抽象基类的UML类图 ","date":"2020-11-09","objectID":"/PythonTrick2/:0:6","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.7 isinstence和type的区别 class A(object): pass class B(A): pass b = B() print(isinstance(b, B)) print(isinstance(b, A)) print(type(b) is B) print(type(b) is A) # True # True # True # False ","date":"2020-11-09","objectID":"/PythonTrick2/:0:7","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.8 类变量和实例变量 实例变量只能通过类的实例进行调用 修改模板对象创建的对象的属性，模板对象的属性不会改变 修改模板对象的属性，由模板对象创建的对象的属性会改变 # 此处的类也是模板对象，Python中一切皆对象 class A(object): #类变量 number = 12 def __init__(self): # 实例变量 self.number_2 = 13 # 实例变量只能通过类的实例进行调用 print(A.number) # 12 print(A().number) # 12 print(A().number_2) # 13 # 修改模板对象创建的对象的属性，模板对象的属性不会改变 a = A() a.number = 18 print(a.number) # 18 print(A().number) # 12 print(A.number) # 12 # 修改模板对象的属性，由模板对象创建的对象的属性会改变 A.number = 19 print(A.number) # 19 print(A().number) # 19 ","date":"2020-11-09","objectID":"/PythonTrick2/:0:8","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.9 类和实例属性以及方法的查找顺序 在Python 2.2之前只有经典类，到Python2.7还会兼容经典类，Python3.x以后只使用新式类，Python之前版本也会兼容新式类 Python 2.2 及其之前类没有基类，Python新式类需要显式继承自 object ，即使不显式继承也会默认继承自 object 经典类在类多重继承的时候是采用从左到右深度优先原则匹配方法的.而新式类是采用C3算法 经典类没有 MRO 和instance.mro()调用的 假定存在以下继承关系： class D(object): def say_hello(self): pass class E(object): pass class B(D): pass class C(E): pass class A(B, C): pass 采用DFS（深度优先搜索算法）当调用了A的say_hello()方法的时候，系统会去B中查找如果B中也没有找到，那么去D中查找，很显然D中存在这个方法，但是DFS对于以下继承关系就会有缺陷： class D(object): pass class B(D): pass class C(D): def say_hello(self): pass class A(B, C): pass 在A的实例对象中调用say_hello方法时，系统会先去B中查找，由于B类中没有该方法的定义，所以会去D中查找，D类中也没有，系统就会认为该方法没有定义，其实该方法在C中定义了。所以考虑使用BFS（广度优先搜索算法），那么问题回到第一个继承关系，假定C和D具备重名方法，在调用A的实例的方法时，应该先在B中查找，理应调用D中的方法，但是使用BFS的时候，C类中的方法会覆盖D类中的方法。在Python 2.3以后的版本中，使用C3算法： # 获取解析顺序的方法 类名.mro() 类名.__mro__ inspect.getmro(类名) 使用C3算法后的第二种继承顺序： class D(object): pass class B(D): pass class C(D): def say_hello(self): pass class A(B, C): pass print(A.mro()) # [\u003cclass '__main__.A'\u003e, \u003cclass '__main__.B'\u003e, \u003cclass '__main__.C'\u003e, \u003cclass '__main__.D'\u003e, \u003cclass 'object'\u003e] 使用C3算法后的第一种继承顺序： class D(object): pass class E(object): pass class B(D): pass class C(E): pass class A(B, C): pass print(A.mro()) # [\u003cclass '__main__.A'\u003e, \u003cclass '__main__.B'\u003e, \u003cclass '__main__.D'\u003e, \u003cclass '__main__.C'\u003e, \u003cclass '__main__.E'\u003e, \u003cclass 'object'\u003e] 在这里仅介绍了算法的作用和演变历史，关于深入详细解析，请看我的其他文章——《从Python继承谈起，到C3算法落笔》。 ","date":"2020-11-09","objectID":"/PythonTrick2/:0:9","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.10 类方法、实例方法和静态方法 class Demo(object): # 类方法 @classmethod def class_method(cls, number): pass # 静态方法 @staticmethod def static_method(number): pass # 对象方法/实例方法 def object_method(self, number): pass 实例方法只能通过类的实例来调用；静态方法是一个独立的、无状态的函数，紧紧依托于所在类的命名空间上；类方法在为了获取类中维护的数据，比如： class Home(object): # 房间中人数 __number = 0 @classmethod def add_person_number(cls): cls.__number += 1 @classmethod def get_person_number(cls): return cls.__number def __new__(self): Home.add_person_number() # 重写__new__方法，调用object的__new__ return super().__new__(self) class Person(Home): def __init__(self): # 房间人员姓名 self.name = 'name' # 创建人员对象时调用Home的__new__()方法 tom = Person() print(type(tom)) # \u003cclass '__main__.Person'\u003e alice = Person() bob = Person() test = Person() print(Home.get_person_number()) ","date":"2020-11-09","objectID":"/PythonTrick2/:0:10","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.11 数据封装和私有属性 Python中使用双下划线+属性名称实现类似于静态语言中的private修饰来实现数据封装。 class User(object): def __init__(self, number): self.__number = number self.__number_2 = 0 def set_number(self, number): self.__number = number def get_number(self): return self.__number def set_number_2(self, number2): self.__number_2 = number2 # self.__number2 = number2 def get_number_2(self): return self.__number_2 # return self.__number2 u = User(25) print(u.get_number()) # 25 # 真的类似于Java的反射机制吗？ print(u._User__number) # 25 # 下面又是啥情况。。。想不明白了T_T u.set_number_2(18) print(u.get_number_2()) # 18 print(u._User__number_2) # Anaconda 3.6.3 第一次是：u._User__number_2 第二次是：18 # Anaconda 3.6.5 结果都是 0 # 代码我改成了正确答案，感谢我大哥给我指正错误，我保留了错误痕迹 # 变量名称写错了，算是个写博客突发事故，这问题我找了一天，万分感谢我大哥，我太傻B了，犯了低级错误 # 留给和我一样的童鞋参考我的错我之处吧！ # 正确结果： # 25 25 18 18 ","date":"2020-11-09","objectID":"/PythonTrick2/:0:11","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.12 Python的自省机制 自省（introspection）是一种自我检查行为。在计算机编程中，自省是指这种能力：检查某些事物以确定它是什么、它知道什么以及它能做什么。自省向程序员提供了极大的灵活性和控制力。 dir([obj])：返回传递给它的任何对象的属性名称经过排序的列表（会有一些特殊的属性不包含在内） getattr(obj, attr)：返回任意对象的任何属性 ，调用这个方法将返回obj中名为attr值的属性的值 … … ","date":"2020-11-09","objectID":"/PythonTrick2/:0:12","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.13 super函数 Python3.x 和 Python2.x 的一个区别是: Python 3 可以使用直接使用 super().xxx 代替 super(type[, object-or-type]).xxx 。 super()函数用来调用MRO（类方法解析顺序表）的下一个类的方法。 ","date":"2020-11-09","objectID":"/PythonTrick2/:0:13","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.14 Mixin继承 在设计上将Mixin类作为功能混入继承自Mixin的类。使用Mixin类实现多重继承应该注意： Mixin类必须表示某种功能 职责单一，如果要有多个功能，就要设计多个Mixin类 不依赖子类实现，Mixin类的存在仅仅是增加了子类的功能特性 即使子类没有继承这个Mixin类也可以工作 class Cat(object): def eat(self): print(\"I can eat.\") def drink(self): print(\"I can drink.\") class CatFlyMixin(object): def fly(self): print(\"I can fly.\") class CatJumpMixin(object): def jump(self): print(\"I can jump.\") class TomCat(Cat, CatFlyMixin): pass class PersianCat(Cat, CatFlyMixin, CatJumpMixin): pass if __name__ == '__main__': # 汤姆猫没有跳跃功能 tom = TomCat() tom.fly() tom.eat() tom.drink() # 波斯猫混入了跳跃功能 persian = PersianCat() persian.drink() persian.eat() persian.fly() persian.jump() ","date":"2020-11-09","objectID":"/PythonTrick2/:0:14","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.25 上下文管理器with语句与contextlib简化 普通的异常捕获机制： try: pass except Exception as err: pass else: pass finally: pass with简化了异常捕获写法： class Demo(object): def __enter__(self): print(\"enter...\") return self def __exit__(self, exc_type, exc_val, exc_tb): print(\"exit...\") def echo_hello(self): print(\"Hello, Hello...\") with Demo() as d: d.echo_hello() # enter... # Hello, Hello... # exit... import contextlib # 使用装饰器 @contextlib.contextmanager def file_open(file_name): # 此处写__enter___函数中定义的代码 print(\"enter function code...\") yield {} # 此处写__exit__函数中定义的代码 print(\"exit function code...\") with file_open(\"json.json\") as f: pass # enter function code... # exit function code... ","date":"2020-11-09","objectID":"/PythonTrick2/:0:15","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.26 序列类型的分类 容器序列：list tuple deque 扁平序列：str bytes bytearray array.array 可变序列：list deque bytearray array 不可变序列：str tuple bytes ","date":"2020-11-09","objectID":"/PythonTrick2/:0:16","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.27 +、+=、extend()之间的区别于应用场景 首先看测试用例： # 创建一个序列类型的对象 my_list = [1, 2, 3] # 将现有的序列合并到my_list extend_my_list = my_list + [4, 5] print(extend_my_list) # [1, 2, 3, 4, 5] # 将一个元组合并到这个序列 extend_my_list = my_list + (6, 7) # 抛出异常 TypeError: can only concatenate list (not \"tuple\") to list print(extend_my_list) # 使用另一种方式合并 extend_my_list += (6, 7) print(extend_my_list) # [1, 2, 3, 4, 5, 6, 7] # 使用extend()函数进行合并 extend_my_list.extend((7, 8)) print(extend_my_list) # [1, 2, 3, 4, 5, 6, 7, 7, 8] 由源代码片段可知： class MutableSequence(Sequence): __slots__ = () \"\"\"All the operations on a read-write sequence. Concrete subclasses must provide __new__ or __init__, __getitem__, __setitem__, __delitem__, __len__, and insert(). \"\"\" # extend()方法内部使用for循环来append()元素，它接收一个可迭代序列 def extend(self, values): 'S.extend(iterable) -- extend sequence by appending elements from the iterable' for v in values: self.append(v) # 调用 += 运算的时候就是调用该函数，这个函数内部调用extend()方法 def __iadd__(self, values): self.extend(values) return self ","date":"2020-11-09","objectID":"/PythonTrick2/:0:17","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.28 使用bisect维护一个已排序的序列 import bisect my_list = [] bisect.insort(my_list, 2) bisect.insort(my_list, 9) bisect.insort(my_list, 5) bisect.insort(my_list, 5) bisect.insort(my_list, 1) # insort()函数返回接收的元素应该插入到指定序列的索引位置 print(my_list) # [1, 2, 5, 5, 9] ","date":"2020-11-09","objectID":"/PythonTrick2/:0:18","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.29 deque类详解 deque是Python中一个双端队列，能在队列两端以$O(1)$的效率插入数据，位于collections模块中。 from collections import deque # 定义一个双端队列，长度为3 d = deque(maxlen=3) deque类的源码： class deque(object): \"\"\" deque([iterable[, maxlen]]) --\u003e deque object 一个类似列表的序列，用于对其端点附近的数据访问进行优化。 \"\"\" def append(self, *args, **kwargs): \"\"\" 在队列右端添加数据 \"\"\" pass def appendleft(self, *args, **kwargs): \"\"\" 在队列左端添加数据 \"\"\" pass def clear(self, *args, **kwargs): \"\"\" 清空所有元素 \"\"\" pass def copy(self, *args, **kwargs): \"\"\" 浅拷贝一个双端队列 \"\"\" pass def count(self, value): \"\"\" 统计指定value值的出现次数 \"\"\" return 0 def extend(self, *args, **kwargs): \"\"\" 使用迭代的方式扩展deque的右端 \"\"\" pass def extendleft(self, *args, **kwargs): \"\"\" 使用迭代的方式扩展deque的左端 \"\"\" pass def index(self, value, start=None, stop=None): __doc__ \"\"\" 返回第一个符合条件的索引的值 \"\"\" return 0 def insert(self, index, p_object): \"\"\" 在指定索引之前插入 \"\"\" pass def pop(self, *args, **kwargs): # real signature unknown \"\"\" 删除并返回右端的一个元素 \"\"\" pass def popleft(self, *args, **kwargs): # real signature unknown \"\"\" 删除并返回左端的一个元素 \"\"\" pass def remove(self, value): # real signature unknown; restored from __doc__ \"\"\" 删除第一个与value相同的值 \"\"\" pass def reverse(self): # real signature unknown; restored from __doc__ \"\"\" 翻转队列 \"\"\" pass def rotate(self, *args, **kwargs): # real signature unknown \"\"\" 向右旋转deque N步， 如果N是个负数，那么向左旋转N的绝对值步 \"\"\" pass def __add__(self, *args, **kwargs): # real signature unknown \"\"\" Return self+value. \"\"\" pass def __bool__(self, *args, **kwargs): # real signature unknown \"\"\" self != 0 \"\"\" pass def __contains__(self, *args, **kwargs): # real signature unknown \"\"\" Return key in self. \"\"\" pass def __copy__(self, *args, **kwargs): # real signature unknown \"\"\" Return a shallow copy of a deque. \"\"\" pass def __delitem__(self, *args, **kwargs): # real signature unknown \"\"\" Delete self[key]. \"\"\" pass def __eq__(self, *args, **kwargs): # real signature unknown \"\"\" Return self==value. \"\"\" pass def __getattribute__(self, *args, **kwargs): # real signature unknown \"\"\" Return getattr(self, name). \"\"\" pass def __getitem__(self, *args, **kwargs): # real signature unknown \"\"\" Return self[key]. \"\"\" pass def __ge__(self, *args, **kwargs): # real signature unknown \"\"\" Return self\u003e=value. \"\"\" pass def __gt__(self, *args, **kwargs): # real signature unknown \"\"\" Return self\u003evalue. \"\"\" pass def __iadd__(self, *args, **kwargs): # real signature unknown \"\"\" Implement self+=value. \"\"\" pass def __imul__(self, *args, **kwargs): # real signature unknown \"\"\" Implement self*=value. \"\"\" pass def __init__(self, iterable=(), maxlen=None): # known case of _collections.deque.__init__ \"\"\" deque([iterable[, maxlen]]) --\u003e deque object A list-like sequence optimized for data accesses near its endpoints. # (copied from class doc) \"\"\" pass def __iter__(self, *args, **kwargs): # real signature unknown \"\"\" Implement iter(self). \"\"\" pass def __len__(self, *args, **kwargs): # real signature unknown \"\"\" Return len(self). \"\"\" pass def __le__(self, *args, **kwargs): # real signature unknown \"\"\" Return self\u003c=value. \"\"\" pass def __lt__(self, *args, **kwargs): # real signature unknown \"\"\" Return self\u003cvalue. \"\"\" pass def __mul__(self, *args, **kwargs): # real signature unknown \"\"\" Return self*value.n \"\"\" pass @staticmethod # known case of __new__ def __new__(*args, **kwargs): # real signature unknown \"\"\" Create and return a new object. See help(type) for accurate signature. \"\"\" pass def __ne__(self, *args, **kwargs): # real signature unknown \"\"\" Return self!=value. \"\"\" pass def __reduce__(self, *args, **kwargs): # real signature unknown \"\"\" Return state information for pickling. \"\"\" pass def __repr__(self, *args, **kwargs): # real signature unknown \"\"\" Return repr(self). \"\"\" pass def __reversed__(self): # real signature unknown; restored from __doc__ \"\"\" D.__reversed__() -- return a reverse iterator over the deque \"\"\" pass def __rmul__(self, *args, **kwargs): # real signature unknown \"\"\" Return self*value. \"\"\" pass def __setitem__(self, *args, **kwargs): # real signature unknown \"\"\" Set self[key] to value. \"\"\" pass def __sizeof__(se","date":"2020-11-09","objectID":"/PythonTrick2/:0:19","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.30 列表推导式、生成器表达式、字典推导式 列表推导式 列表生成式要比操作列表效率高很多，但是列表生成式的滥用会导致代码可读性降低，并且列表生成式可以替换 map() 和 reduce() 函数。 # 构建列表 my_list = [x for x in range(9)] print(my_list) # [0, 1, 2, 3, 4, 5, 6, 7, 8] # 构建0-8中为偶数的列表 my_list = [x for x in range(9) if(x%2==0)] print(my_list) # [0, 2, 4, 6, 8] # 构建0-8为奇数的列表，并将每个数字做平方运算 def function(number): return number * number my_list = [function(x) for x in range(9) if x%2!=0] print(my_list) # [1, 9, 25, 49] 生成器表达式 生成器表达式就是把列表表达式的中括号变成小括号。 # 构造一个生成器 gen = (i for i in range(9)) # 生成器可以被遍历 for i in gen: print(i) 生成器可以使用 list() 函数转换为列表： # 将生成器转换为列表 li = list(gen) print(li) 字典推导式 d = { 'tom': 18, 'alice': 16, 'bob': 20, } dict = {key: value for key, value in d.items()} print(dict) # {'tom': 18, 'alice': 16, 'bob': 20} Set集合推导式 my_set = {i for i in range(9)} print(my_set) # {0, 1, 2, 3, 4, 5, 6, 7, 8} ","date":"2020-11-09","objectID":"/PythonTrick2/:0:20","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.31 Set与Dict的实现原理 Set和Dict的背后实现都是Hash(哈希)表，有的书本上也较散列表。Hash表原理可以参考我的 算法与数学 博客栏目，下面给出几点总结： Set和Dict的效率高于List。 Se和Dict的Key必须是可哈希的元素。 在Python中，不可变对象都是可哈希的，比如：str、fronzenset、tuple，需要实现 __hash__() 函数。 Dict内存空间占用多，但是速度快，Python中自定义对象或Python内部对象都是Dict包装的。 Dict和Set的元素存储顺序和元素的添加顺序有关，但是添加元素时有可能改变已有的元素顺序。 List会随着元素数量的增加，查找元素的时间也会增大。 Dict和Set不会随着元素数量的增加而查找时间延长。 ","date":"2020-11-09","objectID":"/PythonTrick2/:0:21","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.32 Python中的集合类模块collections defaultdict defaultdict 在 dict 的基础上添加了 default_factroy 方法，它的作用是当key不存在的时候自动生成相应类型的value， defalutdict 参数可以指定成 list、set、int 等各种类型。 应用场景： from collections import defaultdict my_list = [ (\"Tom\", 18), (\"Tom\", 20), (\"Alice\", 15), (\"Bob\", 21), ] def_dict = defaultdict(list) for key, val in my_list: def_dict[key].append(val) print(def_dict.items()) # dict_items([('Tom', [18, 20]), ('Alice', [15]), ('Bob', [21])]) # 如果不考虑重复元素可以使用如下方式 def_dict_2 = defaultdict(set) for key, val in my_list: def_dict_2[key].add(val) print(def_dict_2.items()) # dict_items([('Tom', {18, 20}), ('Alice', {15}), ('Bob', {21})]) 源码： class defaultdict(Dict[_KT, _VT], Generic[_KT, _VT]): default_factory = ... # type: Callable[[], _VT] @overload def __init__(self, **kwargs: _VT) -\u003e None: ... @overload def __init__(self, default_factory: Optional[Callable[[], _VT]]) -\u003e None: ... @overload def __init__(self, default_factory: Optional[Callable[[], _VT]], **kwargs: _VT) -\u003e None: ... @overload def __init__(self, default_factory: Optional[Callable[[], _VT]], map: Mapping[_KT, _VT]) -\u003e None: ... @overload def __init__(self, default_factory: Optional[Callable[[], _VT]], map: Mapping[_KT, _VT], **kwargs: _VT) -\u003e None: ... @overload def __init__(self, default_factory: Optional[Callable[[], _VT]], iterable: Iterable[Tuple[_KT, _VT]]) -\u003e None: ... @overload def __init__(self, default_factory: Optional[Callable[[], _VT]], iterable: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -\u003e None: ... def __missing__(self, key: _KT) -\u003e _VT: ... # TODO __reversed__ def copy(self: _DefaultDictT) -\u003e _DefaultDictT: ... OrderedDict OrderDict最大的特点就是元素位置有序，它是 dict 的子类。OrderDict在内部维护一个字典元素的有序列表。 应用场景： from collections import OrderedDict my_dict = { \"Bob\": 20, \"Tim\": 20, \"Amy\": 18, } # 通过key来排序 order_dict = OrderedDict(sorted(my_dict.items(), key=lambda li: li[1])) print(order_dict) # OrderedDict([('Amy', 18), ('Bob', 20), ('Tim', 20)]) 源码： class OrderedDict(dict): 'Dictionary that remembers insertion order' # An inherited dict maps keys to values. # The inherited dict provides __getitem__, __len__, __contains__, and get. # The remaining methods are order-aware. # Big-O running times for all methods are the same as regular dictionaries. # The internal self.__map dict maps keys to links in a doubly linked list. # The circular doubly linked list starts and ends with a sentinel element. # The sentinel element never gets deleted (this simplifies the algorithm). # The sentinel is in self.__hardroot with a weakref proxy in self.__root. # The prev links are weakref proxies (to prevent circular references). # Individual links are kept alive by the hard reference in self.__map. # Those hard references disappear when a key is deleted from an OrderedDict. def __init__(*args, **kwds): '''Initialize an ordered dictionary. The signature is the same as regular dictionaries. Keyword argument order is preserved. ''' if not args: raise TypeError(\"descriptor '__init__' of 'OrderedDict' object \" \"needs an argument\") self, *args = args if len(args) \u003e 1: raise TypeError('expected at most 1 arguments, got %d' % len(args)) try: self.__root except AttributeError: self.__hardroot = _Link() self.__root = root = _proxy(self.__hardroot) root.prev = root.next = root self.__map = {} self.__update(*args, **kwds) def __setitem__(self, key, value, dict_setitem=dict.__setitem__, proxy=_proxy, Link=_Link): 'od.__setitem__(i, y) \u003c==\u003e od[i]=y' # Setting a new item creates a new link at the end of the linked list, # and the inherited dictionary is updated with the new key/value pair. if key not in self: self.__map[key] = link = Link() root = self.__root last = root.prev link.prev, link.next, link.key = last, root, key last.next = link root.prev = proxy(link) dict_setitem(self, key, value) def __delitem__(self, key, dict_delitem=dict.__delitem__): 'od.__delitem__(y) \u003c==\u003e del od[y]' # Deleting an existing item uses self.__map to find the link which gets # removed by updating the links in the predecessor and succ","date":"2020-11-09","objectID":"/PythonTrick2/:0:22","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.33 Python中的变量与垃圾回收机制 Python与Java的变量本质上不一样，Python的变量本事是个指针。当Python解释器执行 number=1 的时候，实际上先在内存中创建一个 int 对象，然后将 number 指向这个 int 对象的内存地址，也就是将 number “贴”在 int 对象上，测试用例如下： number = [1, 2, 3] demo = number demo.append(4) print(number) # [1, 2, 3, 4] == 和 is 的区别就是前者判断的值是否相等，后者判断的是对象id值是否相等。 class Person(object): pass p_0 = Person() p_1 = Person() print(p_0 is p_1) # False print(p_0 == p_1) # False print(id(p_0)) # 2972754016464 print(id(p_1)) # 2972754016408 li_a = [1, 2, 3, 4] li_b = [1, 2, 3, 4] print(li_a is li_b) # False print(li_a == li_b) # True print(id(li_a)) # 2972770077064 print(id(li_b)) # 2972769996680 a = 1 b = 1 print(a is b) # True print(a == b) # True print(id(a)) # 1842179136 print(id(b)) # 1842179136 Python有一个优化机制叫 intern ，像这种经常使用的小整数、小字符串，在运行时就会创建，并且全局唯一。 Python中的 del 语句并不等同于C++中的 delete ，Python中的 del 是将这个对象的指向删除，当这个对象没有任何指向的时候，Python虚拟机才会删除这个对象。 ","date":"2020-11-09","objectID":"/PythonTrick2/:0:23","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.34 Python元类编程 property动态属性 class Home(object): def __init__(self, age): self.__age = age @property def age(self): return self.__age if __name__ == '__main__': home = Home(21) print(home.age) # 21 在Python中，为函数添加 @property 装饰器可以使得函数像变量一样访问。 __getattr__和__getattribute__函数的使用 __getattr__在查找属性的时候，找不到该属性就会调用这个函数。 class Demo(object): def __init__(self, user, passwd): self.user = user self.password = passwd def __getattr__(self, item): return 'Not find Attr.' if __name__ == '__main__': d = Demo('Bob', '123456') print(d.User) __getattribute__在调用属性之前会调用该方法。 class Demo(object): def __init__(self, user, passwd): self.user = user self.password = passwd def __getattr__(self, item): return 'Not find Attr.' def __getattribute__(self, item): print('Hello.') if __name__ == '__main__': d = Demo('Bob', '123456') print(d.User) # Hello. # None 属性描述符 在一个类中实现 __get__()、__set__() 和 __delete__() 都是属性描述符。 数据属性描述符 import numbers class IntField(object): def __init__(self): self.v = 0 def __get__(self, instance, owner): return self.v def __set__(self, instance, value): if(not isinstance(value, numbers.Integral)): raise ValueError(\"Int value need.\") self.v = value def __delete__(self, instance): pass 非数据属性描述符 在Python的新式类中，对象属性的访问都会调用 __getattribute__() 方法，它允许我们在访问对象时自定义访问行为，值得注意的是小心无限递归的发生。 __getattriubte__() 是所有方法和属性查找的入口，当调用该方法之后会根据一定规则在 __dict__ 中查找相应的属性值或者是对象，如果没有找到就会调用 __getattr__() 方法，与之对应的 __setattr__() 和 __delattr__() 方法分别用来自定义某个属性的赋值行为和用于处理删除属性的行为。描述符的概念在Python 2.2中引进， __get__()、__set__()、__delete__() 分别定义取出、设置、删除描述符的值的行为。 值得注意的是，只要实现这三种方法中的任何一个都是描述符。 仅实现 __get__（） 方法的叫做非数据描述符，只有在初始化之后才能被读取。 同时实现 __get__() 和 __set__() 方法的叫做数据描述符，属性是可读写的。 属性访问的优先规则 对象的属性一般是在 __dict__ 中存储，在Python中， __getattribute__() 实现了属性访问的相关规则。 假定存在实例 obj ，属性 number 在 obj 中的查找过程是这样的： 搜索基类列表 type(b).__mro__ ，直到找到该属性，并赋值给 descr 。 判断 descr 的类型，如果是数据描述符则调用 descr.__get__(b, type(b)) ，并将结果返回。 如果是其他的（非数据描述符、普通属性、没找到的类型）则查找实例 obj 的实例属性，也就是 obj.__dict__ 。 如果在 obj.__dict__ 没有找到相关属性，就会重新回到 descr 的判断上。 如果再次判断 descr 类型为非数据描述符，就会调用 descr.__get__(b, type(b)) ，并将结果返回，结束执行。 如果 descr 是普通属性，直接就返回结果。 如果第二次没有找到，为空，就会触发 AttributeError 异常，并且结束查找。 用流程图表示： __new__() 和 __init__() 的区别 __new__() 函数用来控制对象的生成过程，在对象上生成之前调用。 __init__() 函数用来对对象进行完善，在对象生成之后调用。 如果 __new__() 函数不返回对象，就不会调用 __init__() 函数。 自定义元类 在Python中一切皆对象，类用来描述如何生成对象，在Python中类也是对象，原因是它具备创建对象的能力。当Python解释器执行到 class 语句的时候，就会创建这个所谓类的对象。既然类是个对象，那么就可以动态的创建类。这里我们用到 type() 函数，下面是此函数的构造函数源码： def __init__(cls, what, bases=None, dict=None): # known special case of type.__init__ \"\"\" type(object_or_name, bases, dict) type(object) -\u003e the object's type type(name, bases, dict) -\u003e a new type # (copied from class doc) \"\"\" pass 由此可知， type() 接收一个类的额描述返回一个类。 def bar(): print(\"Hello...\") user = type('User', (object, ), { 'name': 'Bob', 'age': 20, 'bar': bar, }) user.bar() # Hello... print(user.name, user.age) # Bob 20 元类用来创建类，因为累也是对象。 type() 之所以可以创建类是由于 tyep() 就是个元类，Python中所有的类都由它创建。在Python中，我们可以通过一个对象的 __class__ 属性来确定这个对象由哪个类产生，当Python创建一个类的对象的时候，Python将在这个类中查找其 __metaclass__ 属性。如果找到了，就用它创建对象，如果没有找到，就去父类中查找，如果还是没有，就去模块中查找，一路下来还没有找到的话，就用 type() 创建。创建元类可以使用下面的写法： class MetaClass(type): def __new__(cls, *args, **kwargs): return super().__new__(cls, *args, **kwargs) class User(metaclass=MetaClass): pass 使用元类创建API 元类的主要用途就是创建API，比如Python中的ORM框架。 Python领袖 Tim Peters ： “元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。” ","date":"2020-11-09","objectID":"/PythonTrick2/:0:24","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Python"],"content":"No.35 迭代器和生成器 当容器中的元素很多的时候，不可能全部读取到内存，那么就需要一种算法来推算下一个元素，这样就不必创建很大的容器，生成器就是这个作用。 Python中的生成器使用 yield 返回值，每次调用 yield 会暂停，因此生成器不会一下子全部执行完成，是当需要结果时才进行计算，当函数执行到 yield 的时候，会返回值并且保存当前的执行状态，也就是函数被挂起了。我们可以使用 next() 函数和 send() 函数恢复生成器，将列表推导式的 [] 换成 () 就会变成一个生成器： my_iter = (x for x in range(10)) for i in my_iter: print(i) 值得注意的是，我们一般不会使用 next() 方法来获取元素，而是使用for循环。当使用while循环时，需要捕获 StopIteration 异常的产生。 Python虚拟机中有一个栈帧的调用栈，栈帧保存了指定的代码的信息和上下文，每一个栈帧都有自己的数据栈和块栈，由于这些栈帧保存在堆内存中，使得解释器有中断和恢复栈帧的能力： import inspect frame = None def foo(): global frame frame = inspect.currentframe() def bar(): foo() bar() print(frame.f_code.co_name) # foo print(frame.f_back.f_code.co_name) # bar 这也是生成器存在的基础。只要我们在任何地方获取生成器对象，都可以开始或暂停生成器，因为栈帧是独立于调用者而存在的，这也是协程的理论基础。 迭代器是一种不同于for循环的访问集合内元素的一种方式，一般用来遍历数据，迭代器提供了一种惰性访问数据的方式。 可以使用for循环的有以下几种类型： 集合数据类型 生成器，包括生成器和带有 yield 的生成器函数 这些可以直接被for循环调用的对象叫做可迭代对象，可以使用 isinstance() 判断一个对象是否为可 Iterable 对象。集合数据类型如 list、dict、str 等是 Iterable 但不是 Iterator ，可以通过 iter() 函数获得一个 Iterator 对象。 send() 和 next() 的区别就在于 send() 可传递参数给 yield() 表达式，这时候传递的参数就会作为 yield 表达式的值，而 yield 的参数是返回给调用者的值，也就是说 send 可以强行修改上一个yield表达式值。 ","date":"2020-11-09","objectID":"/PythonTrick2/:0:25","tags":["Python","Trick"],"title":"Python技巧2","uri":"/PythonTrick2/"},{"categories":["Algorithm"],"content":"LeetCode-821-字符的最短距离 ","date":"2020-11-02","objectID":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/:0:0","tags":["算法"],"title":"LeetCode-821-字符的最短距离","uri":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/"},{"categories":["Algorithm"],"content":"题目 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。 示例 1: 输入: S = “loveleetcode”, C = ‘e’ 输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] 说明: 字符串 S 的长度范围为 [1, 10000]。 C 是一个单字符，且保证是字符串 S 里的字符。 S 和 C 中的所有字母均为小写字母。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2020-11-02","objectID":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/:1:0","tags":["算法"],"title":"LeetCode-821-字符的最短距离","uri":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/"},{"categories":["Algorithm"],"content":"思路 遍历数组，找到等于 C 的字符下标，设置位移坐标pos 遍历数组下标： 依次与 pos 相减取绝对值，再从中选取最小值添加到 ans ","date":"2020-11-02","objectID":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/:2:0","tags":["算法"],"title":"LeetCode-821-字符的最短距离","uri":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/"},{"categories":["Algorithm"],"content":"代码 class Solution: def shortestToChar(self, S: str, C: str) -\u003e List[int]: pos = [] for i, v in enumerate(S): if v == C: pos.append(i) #output：【3，5，6，11】 ans = [] for i in range(len(S)): ans.append(min(abs(t - i) for t in pos)) return ans #[3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0, 3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] ","date":"2020-11-02","objectID":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/:3:0","tags":["算法"],"title":"LeetCode-821-字符的最短距离","uri":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/"},{"categories":["Algorithm"],"content":"复杂度 时间：O(nm) 空间：O(n) ","date":"2020-11-02","objectID":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/:4:0","tags":["算法"],"title":"LeetCode-821-字符的最短距离","uri":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/"},{"categories":["Algorithm"],"content":"LeetCode-66 加一 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:0:0","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"题目 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,9,9,9] 输出: [5,0,0,0] 解释: 输入数组表示数字 5000。 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:1:0","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"解法一 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:2:0","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"思路 将数组中的每一个字符连接成一个字符串； 然后字符串转换为整数，再将数字增加1； 分割数字，组成另一个数组 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:2:1","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"代码 class Solution: def plusOne(self, digits: List[int]) -\u003e List[int]: num = \"\" for i in digits: num += str(i) num = str(int(num) + 1) ans = [] for i in num: ans.append(int(i)) return ans ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:2:2","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"复杂度 空间：O(n) 时间：O(n) ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:2:3","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"解法二 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:3:0","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"思路 和第一种思路类似 遍历数组，将数组变成数字形式 新数字加一 分割数字，组成另一个数组 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:3:1","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"代码 class Solution: def plusOne(self, digits: List[int]) -\u003e List[int]: intNum = 0 for i in range(len(digits)): intNum = intNum*10 + digits[i] intNum += 1 res = [] for i in str(intNum): res.append(int(i)) return res ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:3:2","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"复杂度 空间：O(n) 时间：O(n) ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:3:3","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"解法三 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:4:0","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"思路 换个思路，加一无非两个情况 末位为 9 需要进位 末位不为 9，直接加一 首先设边界条件，若无数字则为一 末位为 9： 截取除最后一位外的数组，末位加一 新数组结尾填零 末位不为 9： 末位直接加一 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:4:1","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"代码 class Solution: def plusOne(self, digits: List[int]) -\u003e List[int]: if len(digits) == 0: digits = [1] elif digits[-1] == 9: digits = self.plusOne(digits[:-1]) digits.extend([0]) else: digits[-1] += 1 return digits 为了好理解些，解释下代码 digits = self.plusOne(digits[:-1]) 示例： digits = [9, 0, 9] # digits = [9, 0, 9] digits = self.plusOne([9, 0]) # this returns [9, 1] # digits = [9, 1] digits.extend([0]) # digits = [9, 1, 0] ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:4:2","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"复杂度 时间：O(n) 空间：O(1) ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:4:3","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Python"],"content":"Python技巧 ","date":"2020-10-09","objectID":"/PythonTrick/:0:0","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"原地交换两数 a = 10 b = 20 a, b = b, a print(b, a) print(a, b) 输出: 10 20 20 10 ","date":"2020-10-09","objectID":"/PythonTrick/:0:1","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"链式比较 n = 10 print(6 \u003c n \u003c 20) print(11 \u003c n \u003c 20) 输出: True False ","date":"2020-10-09","objectID":"/PythonTrick/:0:2","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"三元组操作 [表达式为真的返回值] if [表达式] else [表达式为假的返回值] a = 10 b = 1 if a == 0 else 0 print(b) 输出: 0 ","date":"2020-10-09","objectID":"/PythonTrick/:0:3","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"列表推导 a = [1,4,5,6,2,8,3,7,9] b = [i for i in a if i \u003e 5] print(b) c = [(0,1), (2,3), (4,6)] d = [r[1] for r in c] print(d) 输出: [6, 8, 7, 9] [1, 3, 6] ","date":"2020-10-09","objectID":"/PythonTrick/:0:4","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"列表/元祖切片 a = [1,2,3,4,5,6] # (1,2,3,4,5,6) b = a[2:] c = a[1:2] # 半闭半开 print(b) print(c) 输出: [3, 4, 5, 6] [2] ","date":"2020-10-09","objectID":"/PythonTrick/:0:5","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"基础函数实现 ","date":"2020-10-09","objectID":"/PythonTrick/:1:0","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"函数参数 def test(a, b, *args, ** kwargs): print(a, b, args, kwargs) test(1,2) test(1,2,3,4,t=5) n = [4,5] m = {'x':6, 'y':7} test(1,2, *n, ** m) # 结构传递，等同test(1,2,3,4,x=6,y=7) 输出: 1 2 () {} 1 2 (3, 4) {'t': 5} 1 2 (4, 5) {'x': 6, 'y': 7} ","date":"2020-10-09","objectID":"/PythonTrick/:1:1","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"统计列表中元素次数 a = [1,2,3,3,2,4,5] print(a.count(2)) 输出: 2 方法1 from collections import Counter a = [1,2,3,3,2,4,5] b = Counter(a) print(b) 方法2 a = [1,2,3,3,2,4,5] c = { i: a.count(i) for i in set(a) } print(c) 输出: Counter({2: 2, 3: 2, 1: 1, 4: 1, 5: 1}) {1: 1, 2: 2, 3: 2, 4: 1, 5: 1} ","date":"2020-10-09","objectID":"/PythonTrick/:1:2","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"列表去重 a = [1,2,3,3,2,4,5] b = list(set(a)) print(a, b) 输出: [1, 2, 3, 3, 2, 4, 5] [1, 2, 3, 4, 5] ","date":"2020-10-09","objectID":"/PythonTrick/:1:3","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字典推导 a = [['name','Robin'], ['age',30]] b = { r[0]: r[1] for r in a } print(b) 输出: {‘name': 'Robin', 'age': 30} ","date":"2020-10-09","objectID":"/PythonTrick/:1:4","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字典生成 a = [['name','Robin'], ['age',30]] b = dict(a) print(b) 输出: {'name': 'Robin', 'age': 30} ","date":"2020-10-09","objectID":"/PythonTrick/:1:5","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字典转元组 a = {'name':'Robin', 'age':30} print(list(a.items())) 输出: [('name', 'Robin'), ('age', 30)] ","date":"2020-10-09","objectID":"/PythonTrick/:1:6","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"zip 运用 a = [1,2,3,4] b = ['a','b','c','d'] c = zip(a, b) print(list(c)) 输出: [(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')] ","date":"2020-10-09","objectID":"/PythonTrick/:1:7","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字符串函数 ","date":"2020-10-09","objectID":"/PythonTrick/:2:0","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字符串重复 a = 'a' b = a * 10 print(b) 输出: aaaaaaaaaa ","date":"2020-10-09","objectID":"/PythonTrick/:2:1","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字符串拼接 a = ['Hello', 'World', '!'] b = '~'.join(a) print(b) 输出: Hello~World~! ","date":"2020-10-09","objectID":"/PythonTrick/:2:2","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字符串包含 a = 'Hello World !' print('World' in a) print('abc' in a) 输出: True False ","date":"2020-10-09","objectID":"/PythonTrick/:2:3","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字符串翻转 class Solution: def reverseWords(self, s: str) -\u003e str: # join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。 # strip() 方法用于移除字符串头尾指定的字符（默认为空格）或字符序列。 return \" \".join(s.strip().split()[::-1]) 输出： 输入：\"a good example\" 输出：\"example good a\" 解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 ","date":"2020-10-09","objectID":"/PythonTrick/:2:4","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"列表推导实现 ","date":"2020-10-09","objectID":"/PythonTrick/:3:0","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"map a = [{'name':'A', 'id':1}, {'name':'B', 'id':2}] b = map(lambda d:d['id'], a) print(list(b)) ","date":"2020-10-09","objectID":"/PythonTrick/:3:1","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"列表推导实现 c = [d['id'] for d in a] print(c) 输出: [1, 2] [1, 2] ","date":"2020-10-09","objectID":"/PythonTrick/:3:2","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"filter a = [1,4,5,6,2,8,3,7,9] b = filter(lambda i: i \u003e 5, a) print(list(b)) ","date":"2020-10-09","objectID":"/PythonTrick/:3:3","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"列表推导实现 c = [i for i in a if i \u003e 5] print(c) 输出: [6, 8, 7, 9] [6, 8, 7, 9] ","date":"2020-10-09","objectID":"/PythonTrick/:3:4","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"代码格式优化 ","date":"2020-10-09","objectID":"/PythonTrick/:4:0","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"获取索引和元素 丑代码 a = ['A', 'B', 'C'] n = 0 for i in a: print(n, i) n += 1 for i in range(len(a)): print(i, a[i]) 推荐代码 for n, i in enumerate(a): print(n, i) 输出: 0 A 1 B 2 C 0 A 1 B 2 C 0 A 1 B 2 C ","date":"2020-10-09","objectID":"/PythonTrick/:4:1","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"简化 if a = 1 if a == 1 or a == 2 or a == 3 or a == 8: pass # 不推荐做法 if a in [1,2,3,8,9]: pass # 推荐做法 丑代码 a = 1 if a == 1: b = 'A' elif a == 2: b = 'B' else: b = 'C' print(b) 简化代码 d = {1:'A', 2:'B'} b = d.get(a, 'C') print(b) 输出: A A #web ","date":"2020-10-09","objectID":"/PythonTrick/:4:2","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Iterm2"],"content":"iTerm2 + Oh My Zsh 环境配置 因为powerline以及homebrew均需要安装command line tool，网络条件优越的同学在执行本文下面内容之前，可以先安装XCode并打开运行一次（会初始化安装components），省去以后在iterm2中的等待时间。 另外，git也是必要的，各位可以自行下载安装，除了网络没有任何坑： https://git-scm.com 介于此，本文默认各位同学已经安装了git环境和xcode（command line tools），遇到提示找不到git命令或需要安装command line tool的地方，文中不再赘述了。 ","date":"2020-07-21","objectID":"/Iterm2EnvironmentConfiguration/:0:0","tags":["Iterm2","Oh My Zsh"],"title":"Iterm2 环境配置","uri":"/Iterm2EnvironmentConfiguration/"},{"categories":["Iterm2"],"content":"安装iTerm2 Term2 是一款完全免费的，专为 Mac OS 用户打造的命令行应用。 可以直接去官网下载： https://www.iterm2.com/ 或者键入👇命令： brew cask install iterm2 ","date":"2020-07-21","objectID":"/Iterm2EnvironmentConfiguration/:0:1","tags":["Iterm2","Oh My Zsh"],"title":"Iterm2 环境配置","uri":"/Iterm2EnvironmentConfiguration/"},{"categories":["Iterm2"],"content":"安装Oh my zsh 安装方法有两种，可以使用curl或wget，看自己环境或喜好： # curl 安装方式 sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" # wget 安装方式 sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" Mac系统默认使用dash作为终端，使用命令修改默认使用 zsh： chsh -s /bin/zsh 如果想修改回默认dash，同样使用chsh命令即可： chsh -s /bin/bash ","date":"2020-07-21","objectID":"/Iterm2EnvironmentConfiguration/:0:2","tags":["Iterm2","Oh My Zsh"],"title":"Iterm2 环境配置","uri":"/Iterm2EnvironmentConfiguration/"},{"categories":["Iterm2"],"content":"选择主题 PS gnoster 是常用的 zsh 主题之一，你可以挑选你喜欢的 zsh 主题, 以下以 gnoster 为示例 主题地址 下载 agnoster 主题，执行脚本安装： cd ~/Desktop/OpenSource git clone https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.git cd oh-my-zsh-agnoster-fcamblor/ ./install 执行上面的命令会将主题拷贝到oh my zsh的themes中。 安装成功后，用户$HOME目录下会出现 .zshrc 文件，用 vim ~/.zshrc 打开隐藏文件，将主题配置修改为 agnoster，修改如下 vi ~/.zshrc ZSH_THEME=\"agnoster\" 修改完成后按一下 esc 调出 vi 命令，输入 :wq 保存并退出 vi 模式。 此时command+Q或source配置文件后，iTerm2变了模样： 示例\" 示例 ","date":"2020-07-21","objectID":"/Iterm2EnvironmentConfiguration/:0:3","tags":["Iterm2","Oh My Zsh"],"title":"Iterm2 环境配置","uri":"/Iterm2EnvironmentConfiguration/"},{"categories":["Iterm2"],"content":"安装PowerLine powerline 官网： http://powerline.readthedocs…. 安装 powerline 的方式依然简单，也只需要一条命令： pip install powerline-status --user 没有安装 pip 的同学可能会碰到 zsh: command not found: pip。 使用命令安装 pip 即可： sudo easy_install pip 安装后再次执行安装powerline的命令即可。 ","date":"2020-07-21","objectID":"/Iterm2EnvironmentConfiguration/:0:4","tags":["Iterm2","Oh My Zsh"],"title":"Iterm2 环境配置","uri":"/Iterm2EnvironmentConfiguration/"},{"categories":["Iterm2"],"content":"安装PowerFonts 安装字体库需要首先将项目 git clone 至本地，然后执行源码中的 install.sh。 在你习惯的位置新建一个文件夹，如：~/Desktop/OpenSource/ # git clone git clone https://github.com/powerline/fonts.git --depth=1 # cd to folder cd fonts # run install shell ./install.sh 打开 iTerm2，按 Command + , 键，打开 Preferences 配置界面，然后 Profiles -\u003e Text -\u003e Font -\u003e Chanage Font ，选择 Meslo LG M Regular for Powerline 字体 示例\" 示例 ","date":"2020-07-21","objectID":"/Iterm2EnvironmentConfiguration/:0:5","tags":["Iterm2","Oh My Zsh"],"title":"Iterm2 环境配置","uri":"/Iterm2EnvironmentConfiguration/"},{"categories":["Iterm2"],"content":"安装配色方案 配色方案在使用 VIM 或 Colorful Log 时会变得非常有用，同时界面也不会死板。 同样使用git clone的方式下载源码进行安装： cd ~/Desktop/OpenSource git clone https://github.com/altercation/solarized cd solarized/iterm2-colors-solarized/ open . 在打开的 finder 窗口中，双击 Solarized Dark.itermcolors 和 Solarized Light.itermcolors 即可安装明暗两种配色. 再次进入 iTerm2 -\u003e Preferences -\u003e Profiles -\u003e Colors -\u003e Color Presets 中根据个人喜好选择这两种配色中的一种即可. 示例\" 示例 ","date":"2020-07-21","objectID":"/Iterm2EnvironmentConfiguration/:0:6","tags":["Iterm2","Oh My Zsh"],"title":"Iterm2 环境配置","uri":"/Iterm2EnvironmentConfiguration/"},{"categories":["Iterm2"],"content":"安装高亮插件 这是 oh my zsh 的一个插件，安装方式与 theme 大同小异： cd ~/.oh-my-zsh/custom/plugins/ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git vi ~/.zshrc 这时再次打开 zshrc 文件进行编辑。找到 plugins，此时 plugins 中应该已经有了 git，我们需要把高亮插件也加上： 示例\" 示例 请务必保证插件顺序，zsh-syntax-highlighting 必须在最后一个。 然后在文件的最后一行添加： source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 按一下esc调出vi命令，输入:wq保存并退出vi模式。 执行命令使刚才的修改生效： source ~/.zshrc ","date":"2020-07-21","objectID":"/Iterm2EnvironmentConfiguration/:0:7","tags":["Iterm2","Oh My Zsh"],"title":"Iterm2 环境配置","uri":"/Iterm2EnvironmentConfiguration/"},{"categories":["Iterm2"],"content":"自动命令补全 zsh-autosuggestion 当我们输入命令时，终端会自动提示你接下来可能要输入的命令，这时按 → 便可输出这些命令，非常方便。 cd ~/.oh-my-zsh/custom/plugins/ git clone https://github.com/zsh-users/zsh-autosuggestions vi ~/.zshrc 找到 plugins，加上这个插件即可： 示例\" 示例 ","date":"2020-07-21","objectID":"/Iterm2EnvironmentConfiguration/:0:8","tags":["Iterm2","Oh My Zsh"],"title":"Iterm2 环境配置","uri":"/Iterm2EnvironmentConfiguration/"},{"categories":["Iterm2"],"content":"隐藏用户名和主机名 有时候我们的用户名和主机名太长，比如我的kilien@kilienMacBook-Pro，终端显示的时候会很不好看，我们可以手动去除。 编辑 vim ~/.zshrc 文件，增加 DEFAULT_USER=\"kilien\" 配置，可在文本最好追加。 我们可以通过 whoami 命令，查看当前用户。 参考链接 oh-my-zsh 主题地址 zsh-autosuggestion iTerm2 + Oh My Zsh 打造舒适终端体验 ","date":"2020-07-21","objectID":"/Iterm2EnvironmentConfiguration/:0:9","tags":["Iterm2","Oh My Zsh"],"title":"Iterm2 环境配置","uri":"/Iterm2EnvironmentConfiguration/"},{"categories":["笔记"],"content":"python 生成器和迭代器 PS：这篇博客是我上网课做的笔记，也是参考网课老师的博客，就是学习笔记而已，不喜勿喷！ 本节主要记录一下列表生成式，生成器和迭代器的知识点 ","date":"2020-06-25","objectID":"/GeneratorAndYield/:0:0","tags":["笔记","Generator","Yield"],"title":"生成器的运用","uri":"/GeneratorAndYield/"},{"categories":["笔记"],"content":"列表生成器 首先举个例子 现在有个需求，看列表 [0，1，2，3，4，5，6，7，8，9]，要求你把列表里面的每个值加1，你怎么实现呢？ 方法一（简单）： info = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] b = [] # for index,i in enumerate(info): # print(i+1) # b.append(i+1) # print(b) for index,i in enumerate(info): info[index] +=1 print(info) 方法二（一般）： info = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] a = map(lambda x:x+1,info) print(a) for i in a: print(i) 方法三（高级）： info = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] a = [i+1 for i in range(10)] print(a) ","date":"2020-06-25","objectID":"/GeneratorAndYield/:0:1","tags":["笔记","Generator","Yield"],"title":"生成器的运用","uri":"/GeneratorAndYield/"},{"categories":["笔记"],"content":"生成器 什么是生成器？ 通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的，而且创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间，在Python中，这种一边循环一边计算的机制，称为生成器：generator 生成器是一个特殊的程序，可以被用作控制循环的迭代行为，python中生成器是迭代器的一种，使用yield返回值函数，每次调用yield会暂停，而可以使用next()函数和send()函数恢复生成器。 生成器类似于返回值为数组的一个函数，这个函数可以接受参数，可以被调用，但是，不同于一般的函数会一次性返回包括了所有数值的数组，生成器一次只能产生一个值，这样消耗的内存数量将大大减小，而且允许调用函数可以很快的处理前几个返回值，因此生成器看起来像是一个函数，但是表现得却像是迭代器 python中的生成器 　要创建一个generator，有很多种方法，第一种方法很简单， 只有把一个列表生成式的[]中括号改为（）小括号，就创建一个generator 举例如下： #列表生成式 lis = [x*x for x in range(10)] print(lis) #生成器 generator_ex = (x*x for x in range(10)) print(generator_ex) 结果： [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] \u003cgenerator object \u003cgenexpr\u003e at 0x000002A4CBF9EBA0\u003e 那么创建list和generator_ex，的区别是什么呢？从表面看就是[ ]和（）,但是结果却不一样，一个打印出来是列表（因为是列表生成式），而第二个打印出来却是\u003cgenerator object at 0x000002A4CBF9EBA0\u003e，那么如何打印出来generator_ex的每一个元素呢？ 如果要一个个打印出来，可以通过next（）函数获得generator的下一个返回值： #生成器 generator_ex = (x*x for x in range(10)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) 结果： 0 1 4 9 16 25 36 49 64 81 Traceback (most recent call last): File \"列表生成式.py\", line 42, in \u003cmodule\u003e print(next(generator_ex)) StopIteration 大家可以看到，generator保存的是算法，每次调用next(generaotr_ex)就计算出他的下一个元素的值，直到计算出最后一个元素，没有更多的元素时，抛出StopIteration的错误，而且上面这样不断调用是一个不好的习惯，正确的方法是使用for循环，因为generator也是可迭代对象： #生成器 generator_ex = (x*x for x in range(10)) for i in generator_ex: print(i) 结果： 0 1 4 9 16 25 36 49 64 81 所以我们创建一个generator后，基本上永远不会调用next()，而是通过for循环来迭代，并且不需要关心StopIteration的错误，generator非常强大，如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。 比如著名的斐波那契数列，除第一个和第二个数外，任何一个数都可以由前两个相加得到： 1，1，2，3，5，8，12，21，34….. 斐波那契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易： #fibonacci数列 def fib(max): n,a,b =0,0,1 while n \u003c max: a,b =b,a+b n = n+1 print(a) return 'done' a = fib(10) print(fib(10)) a,b = b ,a+b 其实相当于 t =a+b ,a =b ,b =t ，所以不必写显示写出临时变量t，就可以输出斐波那契数列的前N个数字。上面输出的结果如下： 1 1 2 3 5 8 13 21 34 55 1 1 2 3 5 8 13 21 34 55 done 　仔细观察，可以看出， fib 函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。 也就是说上面的函数也可以用generator来实现，上面我们发现，print(b)每次函数运行都要打印，占内存，所以为了不占内存，我们也可以使用生成器，这里叫yield。如下： def fib(max): n,a,b =0,0,1 while n \u003c max: yield b a,b =b,a+b n = n+1 return 'done' a = fib(10) print(fib(10)) 但是返回的不再是一个值，而是一个生成器，和上面的例子一样，大家可以看一下结果： \u003cgenerator object fib at 0x000001C03AC34FC0\u003e 那么这样就不占内存了，这里说一下generator和函数的执行流程，函数是顺序执行的，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次被next（）调用时候从上次的返回yield语句处急需执行，也就是用多少，取多少，不占内存。 def fib(max): n,a,b =0,0,1 while n \u003c max: yield b a,b =b,a+b n = n+1 return 'done' a = fib(10) print(fib(10)) print(a.__next__()) print(a.__next__()) print(a.__next__()) print(\"可以顺便干其他事情\") print(a.__next__()) print(a.__next__()) 结果： \u003cgenerator object fib at 0x0000023A21A34FC0\u003e 1 1 2 可以顺便干其他事情 3 5 　在上面fib的例子，我们在循环过程中不断调用 yield ，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。同样的，把函数改成generator后，我们基本上从来不会用 next() 来获取下一个返回值，而是直接使用 for 循环来迭代： def fib(max): n,a,b =0,0,1 while n \u003c max: yield b a,b =b,a+b n = n+1 return 'done' for i in fib(6): print(i) 结果： 1 1 2 3 5 8 但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果拿不到返回值，那么就会报错，所以为了不让报错，就要进行异常处理，拿到返回值，如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中： def fib(max): n,a,b =0,0,1 while n \u003c max: yield b a,b =b,a+b n = n+1 return 'done' g = fib(6) while True: try: x = next(g) print('generator: ',x) except StopIteration as e: print(\"生成器返回值：\",e.value) break 结果： generator: 1 generator: 1 generator: 2 generator: 3 generator: 5 generator: 8 生成器返回值： done 还可以通过yield实现在单线程的情况下实现并发运算的效果 import time def consumer(name): print(\"%s准备学习啦!\" %name) while True: lesson = yield print(\"开始[%s]了,[%s]老师来讲课了!\" %(lesson,name)) def producer(name): c = consumer('A') c2 = consumer('B') c.__next__() c2.__next__() print(\"同学们开始上课 了!\") for i in range(10","date":"2020-06-25","objectID":"/GeneratorAndYield/:0:2","tags":["笔记","Generator","Yield"],"title":"生成器的运用","uri":"/GeneratorAndYield/"},{"categories":["笔记"],"content":"迭代器（迭代就是循环） 迭代器包含有next方法的实现，在正确的范围内返回期待的数据以及超出范围后能够抛出StopIteration的错误停止迭代。 我们已经知道，可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list,tuple,dict,set,str等 一类是generator，包括生成器和带yield的generator function 这些可以直接作用于for 循环的对象统称为可迭代对象：Iterable 可以使用isinstance()判断一个对象是否为可 Iterable 对象 \u003e\u003e\u003e from collections import Iterable \u003e\u003e\u003e isinstance([], Iterable) True \u003e\u003e\u003e isinstance({}, Iterable) True \u003e\u003e\u003e isinstance('abc', Iterable) True \u003e\u003e\u003e isinstance((x for x in range(10)), Iterable) True \u003e\u003e\u003e isinstance(100, Iterable) False 而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。 所以这里讲一下迭代器 一个实现了iter方法的对象是可迭代的，一个实现next方法并且是可迭代的对象是迭代器。 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 所以一个实现了iter方法和next方法的对象就是迭代器。 可以使用isinstance()判断一个对象是否是 Iterator 对象： \u003e\u003e\u003e from collections import Iterator \u003e\u003e\u003e isinstance((x for x in range(10)), Iterator) True \u003e\u003e\u003e isinstance([], Iterator) False \u003e\u003e\u003e isinstance({}, Iterator) False \u003e\u003e\u003e isinstance('abc', Iterator) False 生成器都是 Iterator 对象，但 list、dict、str 虽然是 Iterable（可迭代对象） ，却不是 Iterator（迭代器） 。 把list、dict、str 等 Iterable 变成 Iterator 可以使用 iter() 函数 ： \u003e\u003e\u003e isinstance(iter([]), Iterator) True \u003e\u003e\u003e isinstance(iter('abc'), Iterator) True 你可能会问，为什么 list、dict、str 等数据类型不是 Iterator ？ 这是因为Python的 Iterator 对象表示的是一个 数据流 ，Iterator对象可以被 next() 函数调用并不断返回下一个数据，直到没有数据时抛出 StopIteration 错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过 next() 函数实现按需计算下一个数据，所以 Iterator 的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator 甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 判断下列数据类型是可迭代对象or迭代器 s='hello' l=[1,2,3,4] t=(1,2,3) d={'a':1} set={1,2,3} f=open('a.txt') s='hello' #字符串是可迭代对象，但不是迭代器 l=[1,2,3,4] #列表是可迭代对象，但不是迭代器 t=(1,2,3) #元组是可迭代对象，但不是迭代器 d={'a':1} #字典是可迭代对象，但不是迭代器 set={1,2,3} #集合是可迭代对象，但不是迭代器 # ************************************* f=open('test.txt') #文件是可迭代对象，是迭代器 #如何判断是可迭代对象，只有__iter__方法，执行该方法得到的迭代器对象。 # 及可迭代对象通过__iter__转成迭代器对象 from collections import Iterator #迭代器 from collections import Iterable #可迭代对象 print(isinstance(s,Iterator)) #判断是不是迭代器 print(isinstance(s,Iterable)) #判断是不是可迭代对象 #把可迭代对象转换为迭代器 print(isinstance(iter(s),Iterator)) 注意：文件的判断 f = open('housing.csv') from collections import Iterator from collections import Iterable print(isinstance(f,Iterator)) print(isinstance(f,Iterable)) True True 　结论：文件是可迭代对象，也是迭代器 小结： 凡是可作用于 for 循环的对象都是 Iterable 类型； 凡是可作用于 next() 函数的对象都是 Iterator 类型，它们表示一个惰性计算的序列； 集合数据类型如 list、dict、str 等是 Iterable 但不是 Iterator ，不过可以通过 iter() 函数获得一个 Iterator 对象。 Python3的 for 循环本质上就是通过不断调用 next() 函数实现的，例如： for x in [1, 2, 3, 4, 5]: pass 实际上完全等价于 # 首先获得Iterator对象: it = iter([1, 2, 3, 4, 5]) # 循环: while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break ","date":"2020-06-25","objectID":"/GeneratorAndYield/:0:3","tags":["笔记","Generator","Yield"],"title":"生成器的运用","uri":"/GeneratorAndYield/"},{"categories":["笔记"],"content":"对yield的总结 （1）通常的for..in…循环中，in后面是一个数组，这个数组就是一个可迭代对象，类似的还有链表，字符串，文件。他可以是a = [1,2,3]，也可以是a = [x*x for x in range(3)]。 它的缺点也很明显，就是所有数据都在内存里面，如果有海量的数据，将会非常耗内存。 （2）生成器是可以迭代的，但是只可以读取它一次。因为用的时候才生成，比如a = (x*x for x in range(3))。!!!!注意这里是小括号而不是方括号。 （3）生成器（generator）能够迭代的关键是他有next()方法，工作原理就是通过重复调用next()方法，直到捕获一个异常。 （4）带有yield的函数不再是一个普通的函数，而是一个生成器generator，可用于迭代 （5）yield是一个类似return 的关键字，迭代一次遇到yield的时候就返回yield后面或者右面的值。而且下一次迭代的时候，从上一次迭代遇到的yield后面的代码开始执行 （6）yield就是return返回的一个值，并且记住这个返回的位置。下一次迭代就从这个位置开始。 （7）带有yield的函数不仅仅是只用于for循环，而且可用于某个函数的参数，只要这个函数的参数也允许迭代参数。 （8）send()和next()的区别就在于send可传递参数给yield表达式，这时候传递的参数就会作为yield表达式的值，而yield的参数是返回给调用者的值，也就是说send可以强行修改上一个yield表达式值。 （9）send()和next()都有返回值，他们的返回值是当前迭代遇到的yield的时候，yield后面表达式的值，其实就是当前迭代yield后面的参数。 （10）第一次调用时候必须先next（）或send（）,否则会报错，send后之所以为None是因为这时候没有上一个yield，所以也可以认为next（）等同于send(None) ","date":"2020-06-25","objectID":"/GeneratorAndYield/:0:4","tags":["笔记","Generator","Yield"],"title":"生成器的运用","uri":"/GeneratorAndYield/"},{"categories":["笔记"],"content":"补充：itertools库学习 库的官网地址：https://docs.python.org/2/library/itertools.html#itertools.permutations （此部分笔记参考博客：https://www.jb51.net/article/123094.htm） 迭代器（生成器）在Python中是一种很常用也很好用的数据结构，比起列表(list)来说，迭代器最大的优势就是延迟计算，按需使用，从而提高开发体验和运行效率，以至于在Python 3中map,filter等操作返回的不再是列表而是迭代器。 话虽这么说但大家平时用到的迭代器大概只有range了，而通过iter函数把列表对象转化为迭代器对象又有点多此一举，这时候我们今天的主角itertools就该上场了。 itertools中的额函数大多数是返回各种迭代器对象，其中很多函数的作用我们平时要写很多代码才能达到，而在运行效率上反而更低，毕竟人家是系统库。 1，itertools.accumulate 简单来说就是累加。 from itertools import accumulate x = accumulate(range(10)) print(list(x)) [0, 1, 3, 6, 10, 15, 21, 28, 36, 45] 2，itertools.permutations 产生指定数目元素的所有排列（顺序有关） from itertools import permutations x = permutations((1,2,3)) print(list(x)) [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)] python 生成器和迭代器有这篇就够了 - 战争热诚 - 博客园 ","date":"2020-06-25","objectID":"/GeneratorAndYield/:0:5","tags":["笔记","Generator","Yield"],"title":"生成器的运用","uri":"/GeneratorAndYield/"},{"categories":["笔记"],"content":"Python单例模式(Singleton)的N种实现 很多初学者喜欢用 全局变量 ，因为这比函数的参数传来传去更容易让人理解。确实在很多场景下用全局变量很方便。不过如果代码规模增大，并且有多个文件的时候，全局变量就会变得比较混乱。你可能不知道在哪个文件中定义了相同类型甚至重名的全局变量，也不知道这个变量在程序的某个地方被做了怎样的操作。 因此对于这种情况，有种更好的实现方式： 单例（Singleton） 单例是一种 设计模式 ，应用该模式的类只会生成一个实例。 单例模式保证了在程序的不同位置都 可以且仅可以取到同一个对象实例 ：如果实例不存在，会创建一个实例；如果已存在就会返回这个实例。因为单例是一个类，所以你也可以为其提供相应的操作方法，以便于对这个实例进行管理。 举个例子来说，比如你开发一款游戏软件，游戏中需要有“场景管理器”这样一种东西，用来管理游戏场景的切换、资源载入、网络连接等等任务。这个管理器需要有多种方法和属性，在代码中很多地方会被调用，且被调用的必须是同一个管理器，否则既容易产生冲突，也会浪费资源。这种情况下，单例模式就是一个很好的实现方法。 单例模式广泛应用于各种开发场景，对于开发者而言是必须掌握的知识点，同时在很多面试中，也是常见问题。本篇文章总结了目前主流的实现单例模式的方法供读者参考。 希望看过此文的同学，在以后被面到此问题时，能直接皮一下面试官，“我会 4 种单例模式实现，你想听哪一种？” 以下是实现方法索引： 使用函数装饰器实现单例 使用类装饰器实现单例 使用 new 关键字实现单例 使用 metaclass 实现单例 ","date":"2020-05-25","objectID":"/singleton/:0:0","tags":["笔记","Singleton"],"title":"单例模式实现","uri":"/singleton/"},{"categories":["笔记"],"content":"使用函数装饰器实现单例 以下是实现代码： def singleton(cls): _instance = {} def inner(): if cls not in _instance: _instance[cls] = cls() return _instance[cls] return inner @singleton class Cls(object): def __init__(self): pass cls1 = Cls() cls2 = Cls() print(id(cls1) == id(cls2)) 输出结果： True 在 Python 中，id 关键字可用来查看对象在内存中的存放位置，这里 cls1 和 cls2 的 id 值相同，说明他们指向了同一个对象。 关于装饰器的知识，有不明白的同学可以查看之前的文章 【编程课堂】装饰器浅析 或者使用搜索引擎再学习一遍。代码中比较巧妙的一点是: 使用不可变的 类地址 作为键，其实例作为值，每次创造实例时，首先查看该类是否存在实例，存在的话直接返回该实例即可，否则新建一个实例并存放在字典中。 ","date":"2020-05-25","objectID":"/singleton/:1:0","tags":["笔记","Singleton"],"title":"单例模式实现","uri":"/singleton/"},{"categories":["笔记"],"content":"使用类装饰器实现单例 代码： class Singleton(object): def __init__(self, cls): self._cls = cls self._instance = {} def __call__(self): if self._cls not in self._instance: self._instance[self._cls] = self._cls() return self._instance[self._cls] @Singleton class Cls2(object): def __init__(self): pass cls1 = Cls2() cls2 = Cls2() print(id(cls1) == id(cls2)) 同时，由于是面对对象的，这里还可以这么用 class Cls3(): pass Cls3 = Singleton(Cls3) cls3 = Cls3() cls4 = Cls3() print(id(cls3) == id(cls4)) 使用 类装饰器实现单例的原理和 函数装饰器 实现的原理相似，理解了上文，再理解这里应该不难。 ","date":"2020-05-25","objectID":"/singleton/:2:0","tags":["笔记","Singleton"],"title":"单例模式实现","uri":"/singleton/"},{"categories":["笔记"],"content":"New、Metaclass 关键字 在接着说另外两种方法之前，需要了解在 Python 中一个类和一个实例是通过哪些方法以怎样的顺序被创造的。 简单来说， 元类 ( metaclass ) 可以通过方法 metaclass 创造了 类(class) ，而 类(class) 通过方法 new 创造了 实例(instance) 。 在单例模式应用中，在创造类的过程中或者创造实例的过程中稍加控制达到最后产生的实例都是一个对象的目的。 本文主讲单例模式，所以对这个 topic 只会点到为止，有感兴趣的同学可以在网上搜索相关内容，几篇参考文章： ","date":"2020-05-25","objectID":"/singleton/:3:0","tags":["笔记","Singleton"],"title":"单例模式实现","uri":"/singleton/"},{"categories":["笔记"],"content":"使用 new 关键字实现单例模式 使用 new 方法在创造实例时进行干预，达到实现单例模式的目的。 class Single(object): _instance = None def __new__(cls, *args, **kw): if cls._instance is None: cls._instance = object.__new__(cls, *args, **kw) return cls._instance def __init__(self): pass single1 = Single() single2 = Single() print(id(single1) == id(single2)) 在理解到 new 的应用后，理解单例就不难了，这里使用了 来存放实例，如果 _instance 为 None，则新建实例，否则直接返回 _instance 存放的实例。 ","date":"2020-05-25","objectID":"/singleton/:4:0","tags":["笔记","Singleton"],"title":"单例模式实现","uri":"/singleton/"},{"categories":["笔记"],"content":"使用 metaclass 实现单例模式 同样，我们在类的创建时进行干预，从而达到实现单例的目的。 在实现单例之前，需要了解使用 type 创造类的方法，代码如下： def func(self): print(\"do sth\") Klass = type(\"Klass\", (), {\"func\": func}) c = Klass() c.func() 以上，我们使用 type 创造了一个类出来。这里的知识是 mataclass 实现单例的基础。 class Singleton(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs) return cls._instances[cls] class Cls4(metaclass=Singleton): pass cls1 = Cls4() cls2 = Cls4() print(id(cls1) == id(cls2)) 这里，我们将 metaclass 指向 Singleton 类，让 Singleton 中的 type 来创造新的 Cls4 实例。 ","date":"2020-05-25","objectID":"/singleton/:5:0","tags":["笔记","Singleton"],"title":"单例模式实现","uri":"/singleton/"},{"categories":["笔记"],"content":"小结 本文虽然是讲单例模式，但在实现单例模式的过程中，涉及到了蛮多高级 Python 语法，包括装饰器、元类、new、type 甚至 super 等等。对于新手同学可能难以理解，其实在工程项目中并不需要你掌握的面面俱到，掌握其中一种，剩下的作为了解即可。 by 周鑫鑫 关于更多的设计模式，给初学者推荐《 Head First 设计模式 》（Head First Design Patterns），此书浅显易懂，在 Head First 系列书籍里面也算是很好的一本。 ","date":"2020-05-25","objectID":"/singleton/:6:0","tags":["笔记","Singleton"],"title":"单例模式实现","uri":"/singleton/"},{"categories":["Homebrew"],"content":"Mac Homebrew 国内镜像源替换或重置 ","date":"2020-05-15","objectID":"/HomebrewMirrorforsource/:0:0","tags":["换源","Homebrew"],"title":"Homebrew 国内镜像换源","uri":"/HomebrewMirrorforsource/"},{"categories":["Homebrew"],"content":"Homebrew 安装 Homebrew是一款包管理工具，目前支持macOS和linux系统。安装方式很简单，将下面👇命令复制到命令行终端运行即可。 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" ","date":"2020-05-15","objectID":"/HomebrewMirrorforsource/:1:0","tags":["换源","Homebrew"],"title":"Homebrew 国内镜像换源","uri":"/HomebrewMirrorforsource/"},{"categories":["Homebrew"],"content":"查看当前Homebrew 镜像源 # brew.git镜像源 git -C \"$(brew --repo)\" remote -v # homebrew-core.git镜像源 git -C \"$(brew --repo homebrew/core)\" remote -v # homebrew-cask.git镜像源 git -C \"$(brew --repo homebrew/cask)\" remote -v ","date":"2020-05-15","objectID":"/HomebrewMirrorforsource/:1:1","tags":["换源","Homebrew"],"title":"Homebrew 国内镜像换源","uri":"/HomebrewMirrorforsource/"},{"categories":["Homebrew"],"content":"Homebrew 换源（科大）： git -C \"$(brew --repo)\" remote set-url origin https://mirrors.ustc.edu.cn/brew.git git -C \"$(brew --repo homebrew/core)\" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git git -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git if [ $SHELL = \"/bin/bash\" ] # 如果你的是bash then echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles/' \u003e\u003e ~/.bash_profile source ~/.bash_profile elif [ $SHELL = \"/bin/zsh\" ] # 如果用的shell 是zsh 的话 then echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles/' \u003e\u003e ~/.zshrc source ~/.zshrc fi brew update ","date":"2020-05-15","objectID":"/HomebrewMirrorforsource/:2:0","tags":["换源","Homebrew"],"title":"Homebrew 国内镜像换源","uri":"/HomebrewMirrorforsource/"},{"categories":["Homebrew"],"content":"恢复原有镜像源（国内镜像源突然不能用了或版本不够新） git -C \"$(brew --repo)\" remote set-url origin https://github.com/Homebrew/brew.git git -C \"$(brew --repo homebrew/core)\" remote set-url origin https://github.com/Homebrew/homebrew-core.git git -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://github.com/Homebrew/homebrew-cask.git # 找到 ~/.bash_profile 或者 ~/.zshrc 中的HOMEBREW_BOTTLE_DOMAIN 一行删除 brew update ","date":"2020-05-15","objectID":"/HomebrewMirrorforsource/:2:1","tags":["换源","Homebrew"],"title":"Homebrew 国内镜像换源","uri":"/HomebrewMirrorforsource/"},{"categories":["Homebrew"],"content":"Homebrew 重置 brew doctor brew update-reset brew update ","date":"2020-05-15","objectID":"/HomebrewMirrorforsource/:3:0","tags":["换源","Homebrew"],"title":"Homebrew 国内镜像换源","uri":"/HomebrewMirrorforsource/"},{"categories":["Homebrew"],"content":"参考链接 Homebrew 推荐阅读 国内镜像地址 科大: https://mirrors.ustc.edu.cn 阿里: https://mirrors.aliyun.com/homebrew/ ","date":"2020-05-15","objectID":"/HomebrewMirrorforsource/:4:0","tags":["换源","Homebrew"],"title":"Homebrew 国内镜像换源","uri":"/HomebrewMirrorforsource/"},{"categories":["npm"],"content":"淘宝npm地址： http://npm.taobao.org/ 临时生效： npm install 软件名 --registry https://registry.npm.taobao.org 永久生效 npm config set registry https://registry.npm.taobao.org 验证： npm config get registry # OR npm info express ","date":"2020-05-15","objectID":"/NpmMirrorforsource/:1:0","tags":["换源","npm"],"title":"npm 国内镜像换源","uri":"/NpmMirrorforsource/"},{"categories":["npm"],"content":"Pip 清华源 pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple ","date":"2020-05-15","objectID":"/NpmMirrorforsource/:2:0","tags":["换源","npm"],"title":"npm 国内镜像换源","uri":"/NpmMirrorforsource/"},{"categories":["npm"],"content":"cnpm（不推荐）： npm install -g --registry=https://registry.npm.taobao.org # 使用 cnpm install install express 国内镜像地址 npm更换国内源–解决npm install慢的问题 ","date":"2020-05-15","objectID":"/NpmMirrorforsource/:3:0","tags":["换源","npm"],"title":"npm 国内镜像换源","uri":"/NpmMirrorforsource/"},{"categories":["Algorithm"],"content":"Swap Nodes in Pairs ","date":"2019-05-29","objectID":"/SwapNodesinPairs/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-24-两两交换链表中的节点","uri":"/SwapNodesinPairs/"},{"categories":["Algorithm"],"content":"Leetcode 24.Swap Nodes in Pairs Given alinked list, swap every two adjacent nodes and return its head. You maynotmodify the values in the list’s nodes, only nodes itself may be changed. Example: Given 1-\u003e2-\u003e3-\u003e4, you should return the list as 2-\u003e1-\u003e4-\u003e3 #Author:kilien #Leetcode 24.Swap Nodes in Pairs #思路：定义哨兵节点，互换相邻节点及后继节点，详见图解 #time:O(n) space:O(n) # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def swapPairs(self, head: ListNode) -\u003e ListNode: pre, pre.next = self, head while pre.next and pre.next.next: a = pre.next b = a.next pre.next, b.next, a.next = b, a, b.next pre = a return self.next 初始状态： pre代表ListNode对象，指向自身None； pre后继节点为head，即第一个节点 后续定义两个指针变量：a,b a指向pre的后继节点 b指向a指针的后继节点，即value为2的节点 第一次循环： 将pre的后继指针指向b指针的节点，即value为2的节点 将b的后继指针指向a指针的节点，即value为1的节点 将a的后继指针指向b指针的后继指针所指节点，即value为3的节点 pre指针赋值为a指针所在位置 第一次循环： a指向pre的后继节点，即value为3的节点 b指向a指针的后继节点，即value为4的节点 将pre的后继指针指向b指针的节点，即value为4的节点 将b的后继指针指向a指针的节点，即value为3的节点 将a的后继指针指向b指针的后继指针所指节点，即尾节点None pre指针赋值为a指针所在位置 ","date":"2019-05-29","objectID":"/SwapNodesinPairs/:0:1","tags":["算法","Leetcode"],"title":"LeetCode-24-两两交换链表中的节点","uri":"/SwapNodesinPairs/"},{"categories":["Algorithm"],"content":"Linked List Cycle Leetcode 141.Linked List Cycle Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integerposwhich represents the position (0-indexed)in the linked list where tail connects to. Ifposis-1, then there is no cycle in the linked list. Example : Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node. 题意： 给定一个链表，判断链表中是否有环。 # Author:kilien # Leetcode 141.Linked List Cycle # 思路1：使用set记录链表元素，重复即有环 # time:O(n) space:O(n) class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" key = set() while head: if head in key: return True else: key.add(head) head = head.next return False # 思路2：使用快慢指针，当两者相遇则有环 # time：O(n) space:O(1) # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" fast = slow = head while fast and slow and fast.next: fast = fast.next.next slow = slow.next if fast is slow: return True return False 过程如图： ","date":"2019-05-27","objectID":"/LinkedListCycle/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-141-环形链表","uri":"/LinkedListCycle/"},{"categories":["Algorithm"],"content":"Sort List ","date":"2019-05-27","objectID":"/SortList/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-148-排序链表","uri":"/SortList/"},{"categories":["Algorithm"],"content":"LeetCode 148.Sort List Sort a linked list inO(nlogn) time using constant space complexity. Example 1: Input: 4-\u003e2-\u003e1-\u003e3 Output: 1-\u003e2-\u003e3-\u003e4 # Author：kilien # 思路：归并排序，分解链表，化整为零，再自底向上合并排序 # time：O（nlogn） space：O（nloagn） # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def merge(self, h1, h2): dummy = tail = ListNode(None) while h1 and h2: if h1.val \u003c h2.val: tail.next, tail, h1 = h1, h1, h1.next else: tail.next, tail, h2 = h2, h2, h2.next tail.next = h1 or h2 return dummy.next def sortList(self, head): if not head or not head.next: return head pre, slow, fast = None, head, head while fast and fast.next: pre, slow, fast = slow, slow.next, fast.next.next pre.next = None return self.merge(*map(self.sortList, (head, slow))) map 运用 map() 函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 \u003e\u003e\u003e def f(x): ... return x * x ... \u003e\u003e\u003e r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) \u003e\u003e\u003e list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81] map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。 ※ 的作用是将map对象作为实参传入merge函数。 具体流程可见图解： 初始状态： sortList\" sortList sortlist循环： sortList\" sortList sortList\" sortList 断链：pre.next = None sortList\" sortList 左子树拆分元素，合并排序 sortList\" sortList 右子树拆分：左1子树和右1子树 sortList\" sortList 左1子树不变，右1子树拆分元素，合并 sortList\" sortList 左1子树、右1子树合并 sortList\" sortList 左右子树合并 sortList\" sortList ","date":"2019-05-27","objectID":"/SortList/:0:1","tags":["算法","Leetcode"],"title":"LeetCode-148-排序链表","uri":"/SortList/"},{"categories":["Algorithm"],"content":"Reverse Linked List ","date":"2019-05-25","objectID":"/reverseLinkedList/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-206-反转链表","uri":"/reverseLinkedList/"},{"categories":["Algorithm"],"content":"Leetcode 206.Reverse Linked List 链表本质是理解“指针”的概念。指针在各种语言都有运用到，只是叫法不同，就像Java中是“引用”。实际上，意思都是存储对象的内存地址。 将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向这个变量，通过内存地址可以找到这个变量值。 大体如下图： array 下面通过一道简单的题目演示下链表移动。 Leetcode 206.Reverse Linked List Reverse a singly linked list. Example: Input: 1-\u003e2-\u003e3-\u003e4-\u003e5-\u003eNULL Output: 5-\u003e4-\u003e3-\u003e2-\u003e1-\u003eNULL #author:kilien #Leetcode 206.Reverse Linked List #思路：定义两个指针，指向前继节点和当前节点 #多元赋值，两两互换 #time:O(n) space:O(1) # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def reverseList(self, head: ListNode) -\u003e ListNode: cur, prev = head, None while cur: cur.next, prev, cur = prev, cur, cur.next return prev 初始状态： 第一次循环： 将当前节点的后继指针指向前继节点，头节点的前继为Null； 将当前节点的前继指针指向当前节点，即指向本身，value为1； 当前节点指针赋值为当前节点的后继节点，即value为2的节点 第二次循环： 将当前节点的后继指针指向前继节点，即value为1的节点； 将当前节点的前继指针指向当前节点，即value为2的节点； 当前节点指针赋值为当前节点的后继节点，即value为3的节点 第三次循环： 将当前节点的后继指针指向前继节点，即value为2的节点； 将当前节点的前继指针指向当前节点，即value为3的节点； 当前节点指针赋值为当前节点的后继节点，即value为None的节点 注：python中多位赋值类似构建一个元组存储临时变量,如下两段代码等价 #cur.next, prev, cur = prev, cur, cur.next tuples = (prev, cur, cur.next) cur.next = tuples[0] prev = tuples[1] cur = tuples[2] 链表中使用该方式需要注意赋值顺序，错位将导致链表断裂 ","date":"2019-05-25","objectID":"/reverseLinkedList/:0:1","tags":["算法","Leetcode"],"title":"LeetCode-206-反转链表","uri":"/reverseLinkedList/"},{"categories":["Algorithm"],"content":"LeetCode 322 零钱兑换 ","date":"2019-05-23","objectID":"/CoinChange/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-322-零钱兑换","uri":"/CoinChange/"},{"categories":["Algorithm"],"content":"题目： 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 **输入:**coins = [1, 2, 5], amount = 11 **输出:**3 **解释:** 11 = 5 + 5 + 1 题意解析： 有一堆不同面额的硬币，问最少取多少枚硬币，可以凑够想要的面值。 ","date":"2019-05-23","objectID":"/CoinChange/:0:1","tags":["算法","Leetcode"],"title":"LeetCode-322-零钱兑换","uri":"/CoinChange/"},{"categories":["Algorithm"],"content":"DFS解析： Coin Change - LeetCode 为了最终硬币数量最少，首先对硬币面值从大到小排序 因为面值大的越靠前，最后所需额度也会相应减小，硬币数量也会减少 构建DFS函数 确定边界，若不存在目标金额，则返回当前最小值 遍历硬币面值： 若存在当前硬币面值小于等于目标金额且目标金额小于边界条件（防止溢出），则drill down，进入下一层循环寻找剩余金额所需硬币 设置目标金额，遍历硬币面值，求解 def coinChange(self, coins, amount): coins.sort(reverse = True) coins_len, self.result = len(coins), float(“inf”) def dfs(index, target, count): if not target: self.res = min(self.res, count) for i in range(index, coins_len): if coins[i] \u003c= target \u003c coins[i] * (self.result-count): # if hope still exists dfs(i, target-coins[i], count+1) for i in range(coins_len): dfs(i, amount, 0) return self.result if self.result \u003c float(“inf”) else -1 ","date":"2019-05-23","objectID":"/CoinChange/:0:2","tags":["算法","Leetcode"],"title":"LeetCode-322-零钱兑换","uri":"/CoinChange/"},{"categories":["Algorithm"],"content":"剪枝 上面方式遍历过程中并不需要全部遍历全部结果，可以通过剪枝，去除多余的选项： 同上对硬币面值排序（从大到小） 构建countCoins函数： 设置金额上限及硬币上限，若当前金额大于目标金额则返回 求模，针对当前硬币和目标金额取模，若满足条件即表示当前的coin可以将目标金额填满，只需要计算coins即可 遍历目标金额，从大至小，依次递减1： 若存在目标金额与对应面值的硬币匹配的情况（求模），则将硬币记录下来 针对目标金额遍历求值即可 import math class Solution: def coinChange(self, coins: List[int], amount: int) -\u003e int: coins.sort(reverse = True) coins_len, result = len(coins), amount + 1 def countCoins(index, target, count): if count + math.ceil(target/coins[index]) \u003e= result: return if target % coins[index] == 0: result = count + target//coins[index] return if index == coins_len - 1: return for i in range(target//coins[index], -1, -1): countCoins(index+1, target - coins[index]*i, count+1) countCoins(0, amount, 0) return -1 if result \u003e amount else result ","date":"2019-05-23","objectID":"/CoinChange/:0:3","tags":["算法","Leetcode"],"title":"LeetCode-322-零钱兑换","uri":"/CoinChange/"},{"categories":["Algorithm"],"content":"BFS 解析 Coin Change - LeetCode 将问题转化为求X轴0点到坐标点amount的最短距离 （每次向前行进的合法距离为coin的面值） visited = [False]*(amount+1) 构建数组，存放后续遍历的节点 和DFS类似，先遍历对应硬币的面值 在这个过程中，计算当前硬币面值与已有硬币的和集，比较当前金额和目标金额的差异（相等则返回并记录硬币，超过目标金额则放弃，不处理） 若 当前金额不在已访问过的数组中，则将当前金额添加至已访问过的数组中 返回遍历后的结果 class Solution(object): def coinChange(self, coins, amount): if amount == 0: return 0 value1 = [0] value2 = [] nc = 0 visited = [False]*(amount+1) visited[0] = True while value1: nc += 1 for v in value1: for coin in coins: newval = v + coin if newval == amount: return nc elif newval \u003e amount: continue elif not visited[newval]: visited[newval] = True value2.append(newval) value1, value2 = value2, [] return -1 ","date":"2019-05-23","objectID":"/CoinChange/:0:4","tags":["算法","Leetcode"],"title":"LeetCode-322-零钱兑换","uri":"/CoinChange/"},{"categories":["Algorithm"],"content":"动态规划解析： Coin Change - LeetCode 首先声明一个大小为amount+1的数组dp，用dp[i]存储”对于金额amount最少用到的硬币数coins” 为什么大小是amount+1？比如amount是11块，dp要从0元开始存储到11块，所以数组的大小要amount+1 对于初始化数组dp的索引i=0的元素值为0，是因为0块要的硬币数为0，所以初始化为0 根据数组dp的定义，得到方程: dp[i] = min(dp[i-coin]+1) 注意：dp[i-coin]的coin是针对每一种硬币 返回值 dp[amount]返回dp数组的最后一个元素，dp[amount] == float(“inf”)返回dp数组最后的元素是否为inf(无穷大) 这里用一个例子解释[3, -1][True]返回的是索引为1的元素，[3, -1][False]返回索引为0的元素 所以dp[amount]不等于inf则返回dp[amount]，等于inf则返回-1，意味着任何一种硬币组合能组成总金额 time: O(amount*len(coins) 第一层循环遍历了amount次，第二层循环遍历了数组coins的每个元素 space: O(amount) 算法用一个大小为amount+1的数组来存储值 class Solution: def coinChange(self, coins: List[int], amount: int) -\u003e int: dp = [0] + [float(“inf”)] * amount for i in range(1, amount + 1): dp[i] = min([dp[i - c] if i - c \u003e= 0 else float(“inf”) for c in coins]) + 1 return [dp[amount], -1][dp[amount] == float(‘inf’)] 如上方式可以转换如下通俗的方式： class Solution: def coinChange(self, coins: List[int], amount: int) -\u003e int: n = len(coins) # dp[i]表示金额amount需要的最少coins数 dp = [float(\"inf\")] * (amount+1) dp[0] = 0 for i in range(amount+1): for j in range(n): if coins[j] \u003c= i: dp[i] = min(dp[i], dp[i-coins[j]]+1) return dp[amount] if dp[amount] \u003c= amount else -1 ","date":"2019-05-23","objectID":"/CoinChange/:0:5","tags":["算法","Leetcode"],"title":"LeetCode-322-零钱兑换","uri":"/CoinChange/"},{"categories":["Algorithm"],"content":"Implement Stack using Queues Leetcode 225. Implement Stack using Queues Implement the following operations of a stack using queues. push(x) — Push element x onto stack. pop() — Removes the element on top of the stack. top() — Get the top element. empty() — Return whether the stack is empty. Example: MyStack stack = new MyStack(); stack.push(1); stack.push(2); stack.top(); // returns 2 stack.pop(); // returns 2 stack.empty(); // returns false # @Author：Kilien # @lc app=leetcode id=225 lang=python3 # [225] Implement Stack using Queues # time:O(1) space:O(n) # 思路：双端队列，左进右出模拟栈 class MyStack: def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.stack = collections.deque([]) def push(self, x: int) -\u003e None: \"\"\" Push element x onto stack. \"\"\" self.stack.append(x) def pop(self) -\u003e int: \"\"\" Removes the element on top of the stack and returns that element. \"\"\" for i in range(len(self.stack) - 1): self.stack.append(self.stack.popleft()) return self.stack.popleft() def top(self) -\u003e int: \"\"\" Get the top element. \"\"\" return self.stack[-1] def empty(self) -\u003e bool: \"\"\" Returns whether the stack is empty. \"\"\" return len(self.stack) == 0 # Your MyStack object will be instantiated and called as such: # obj = MyStack() # obj.push(x) # param_2 = obj.pop() # param_3 = obj.top() # param_4 = obj.empty() Deque定义： Deque队列是由栈或者queue队列生成的（发音是 “deck”，”double-ended queue”的简称）。 Deque支持线程安全，内存高效添加(append)和弹出(pop)，从两端都可以，两个方向的大概开销都是 O(1) 复杂度。 Deque方法： append(x) 添加x到右端。 appendleft(x) 添加x到左端。 pop() 移去并且返回一个元素，deque最右侧的那一个。如果没有元素的话，就升起 IndexError 索引错误。 popleft() 移去并且返回一个元素，deque最左侧的那一个。如果没有元素的话，就升起 IndexError 索引错误。 \u003e\u003e\u003e from collections import deque \u003e\u003e\u003e d = deque('ghi') # make a new deque with three items \u003e\u003e\u003e for elem in d: # iterate over the deque's elements ... print(elem.upper()) G H I \u003e\u003e\u003e d.append('j') # add a new entry to the right side \u003e\u003e\u003e d.appendleft('f') # add a new entry to the left side \u003e\u003e\u003e d # show the representation of the deque deque(['f', 'g', 'h', 'i', 'j']) \u003e\u003e\u003e d.pop() # return and remove the rightmost item 'j' \u003e\u003e\u003e d.popleft() # return and remove the leftmost item 'f' \u003e\u003e\u003e list(d) # list the contents of the deque ['g', 'h', 'i'] \u003e\u003e\u003e d[0] # peek at leftmost item 'g' \u003e\u003e\u003e d[-1] # peek at rightmost item 'i' 具体可见官方文档： collections — 容器数据类型 — Python 3.7.3 文档 ","date":"2019-05-21","objectID":"/ImplementStackusingQueues/:0:0","tags":["算法","Leetcode"],"title":"ImplementStackusingQueues","uri":"/ImplementStackusingQueues/"},{"categories":["Algorithm"],"content":"Implement Queue using Stacks Leetcode 232.Implement Queue using Stacks Implement the following operations of a queue using stacks. push(x) — Push element x to the back of queue. pop() — Removes the element from in front of queue. peek() — Get the front element. empty() — Return whether the queue is empty. Example: MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // returns 1 queue.pop(); // returns 1 queue.empty(); // returns false # @Author：Kilien # @lc app=leetcode id=232 lang=python3 # [232] Implement Queue using Stacks # time:O(1) space:O(n) #思路：两个数组，模拟入栈出栈，实现队列；具体见图解 class MyQueue: def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.inStack, self.outStack = [], [] def push(self, x): \"\"\" :type x: int :rtype: nothing \"\"\" self.inStack.append(x) def pop(self): \"\"\" :rtype: nothing \"\"\" self.move() return self.outStack.pop() def peek(self): \"\"\" :rtype: int \"\"\" self.move() return self.outStack[-1] def empty(self): \"\"\" :rtype: bool \"\"\" return (not self.inStack) and (not self.outStack) def move(self): \"\"\" :rtype nothing \"\"\" if not self.outStack: while self.inStack: self.outStack.append(self.inStack.pop()) # Your MyQueue object will be instantiated and called as such: # obj = MyQueue() # obj.push(x) # param_2 = obj.pop() # param_3 = obj.peek() # param_4 = obj.empty() 初始建两个数组模拟栈： stack1 字符串”1，2，3“入栈： stack2 ”1，2，3“移动至outStack： stack3 ”4，5“入栈，”1，2，3“依次出栈，输出字符串”1，2，3“： stack4 ”4，5“移动至outStack： stack5 输出”4，5“： stack6 ","date":"2019-05-21","objectID":"/ImplementQueueusingStacks/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-232-用栈实现队列","uri":"/ImplementQueueusingStacks/"},{"categories":["Algorithm"],"content":"Valid Parentheses Leetcode 20.Valid Parentheses Given a string containing just the characters’(‘,’)’,’{‘,’}’,’[‘and’]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string isalso considered valid. Example1： Input: “()[]{}” Output: true Example2: Input: “([)]” Output: false # @Author：Kilien # @lc app=leetcode id=20 lang=python3 # # [20] Valid Parentheses # 思路：使用hashtable标记括号，拆分字符串 # 若字符串不在hashtable中，模拟入栈 # 若栈不为空，栈顶元素出栈，匹配括号则消除，不匹配则报错 class Solution: def isValid(self, s: str) -\u003e bool: stack = [] par_map = {')':'(',']':'[','}':'{'} for c in s: if c not in par_map: stack.append(c) elif not stack or par_map[c] != stack.pop(): return False return not stack ","date":"2019-05-20","objectID":"/ValidParentheses/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-20-有效括号","uri":"/ValidParentheses/"},{"categories":["Algorithm"],"content":"Valid Anagram Leetcode 242.Valid Anagram Given two strings s and t , write a function to determine if t is an anagram of s. Example： Input: s = “anagram”, t = “nagaram” Output: true Input: s = “rat”, t = “car” Output: false # @Author：Kilien # @lc app=leetcode id=242 lang=python3 # # [242] Valid Anagram # class Solution: # 思路：数组排序后比较差异 # def isAnagram(self, s: str, t: str) -\u003e bool: # return sorted(s) == sorted(t) # 思路：手动模拟hashtable，将字符串”a-z“的ASCII码作key， #计数求差异 def isAnagram(self, s: str, t: str) -\u003e bool: arr1, arr2 = [0]*26, [0]*26 for i in s: arr1[ord(i) - ord('a')] += 1 for i in t: arr2[ord(i) - ord('a')] += 1 return arr1 == arr2 # 思路：map计数，对比计数差异 \"\"\" def isAnagram(self, s: str, t: str) -\u003e bool: dict1, dict2 = {}, {}for item in s: dict1[item] = dict1.get(item,0) + 1 for item in t: dict2[item] = dict2.get(item,0) + 1 return dict1 == dict2 \"\"\" ","date":"2019-05-20","objectID":"/VaildAnagram/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-242-有效的字母异位词","uri":"/VaildAnagram/"},{"categories":["Algorithm"],"content":"Kth Largest Element in a Stream Leetcoed 703.Kth Largest Element in a Stream Design a class to findthekth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. YourKthLargestclass will have a constructor which accepts an integerkand an integer arraynums, which contains initial elements fromthe stream. For each call to the methodKthLargest.add, return the element representing the kth largest element in the stream. Example int k = 3; int[] arr = [4,5,8,2]; KthLargest kthLargest = new KthLargest(3, arr); kthLargest.add(3); // returns 4 kthLargest.add(5); // returns 5 kthLargest.add(10); // returns 5 kthLargest.add(9); // returns 8 kthLargest.add(4); // returns 8 题意： 设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。 # @Author:Kilien # @lc app=leetcode id=703 lang=python3 # # [703] Kth Largest Element in a Stream # 思路：将列表转化为小顶堆，保证第k个大的元素在堆顶， # 若堆中元素个数小于k，则后续元素入堆，重新排序，直至堆满足k个元素 # 若后续加入元素比堆顶大则剔除堆顶元素，该元素加入小顶堆，重新排序 # 若后续加入元素比堆顶小则忽略 class KthLargest: def __init__(self, k: int, nums: List[int]): self.pool = nums self.k = k heapq.heapify(self.pool) while len(self.pool) \u003e k: heapq.heappop(self.pool) def add(self, val: int) -\u003e int: if len(self.pool) \u003c self.k: heapq.heappush(self.pool, val) elif val \u003e self.pool[0]: heapq.heapreplace(self.pool, val) return self.pool[0] # Your KthLargest object will be instantiated and called as such: # obj = KthLargest(k, nums) # param_1 = obj.add(val) heapq定义： 这个模块提供了堆队列算法的实现，也称为优先队列算法。 堆是一个二叉树，它的每个父节点的值都只会小于或大于所有孩子节点（的值）。它使用了数组来实现：从零开始计数，对于所有的 k ，都有heap[k] \u003c= heap[2k+1]和 heap[k] \u003c= heap[2k+2] 。 为了便于比较，不存在的元素被认为是无限大。堆最有趣的特性在于最小的元素总是在根结点：heap[0] 。 heaoq方法： heapq.heappush(heap, item) 将 item 的值加入 heap 中，保持堆的不变性。 heapq.heappop(heap) 弹出并返回 heap 的最小的元素，保持堆的不变性。如果堆为空，抛出 IndexError 。使用 heap[0] ，可以只访问最小的元素而不弹出它。 heapq.heappushpop(heap, item) 将 item 放入堆中，然后弹出并返回 heap 的最小元素。该组合操作比先调用 heappush() 再调用 heappop() 运行起来更有效率。 heapq.heapify(x) 将list x 转换成堆，原地，线性时间内。 详见官方文档： heapq — 堆队列算法 — Python 3.7.3 文档 ","date":"2019-05-19","objectID":"/KthStream/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-703-数据流中的第 K 大元素","uri":"/KthStream/"},{"categories":["Algorithm"],"content":"LinkedList 链表的结构还是比较直观的，就像一条锁链，换换相扣。程序中它通过 指针将零散的内存块地址串联起来，无须顺序存储；而指针即指向存储对象的内存地址的变量。 将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向这个变量，通过内存地址可以找到这个变量值。 ","date":"2019-05-15","objectID":"/LinkedList/:0:0","tags":["算法"],"title":"LinkedList","uri":"/LinkedList/"},{"categories":["Algorithm"],"content":"链表数据结构 链表节点的结构： class ListNode: def __init__(self, x): self.val = x self.next = None linkedlist 如图所示，一个节点记录两部分内容： 数据域：节点的值，即 23 指针域：对应下个节点的内存地址值，即后继指针 next linkedlist 一般而言，第一个节点称作头节点，最后一个节点称作尾节点； 头节点一般作为链表的起始标记，便于便利链表；尾节点的指针则是指向None,即空地址。 ","date":"2019-05-15","objectID":"/LinkedList/:0:1","tags":["算法"],"title":"LinkedList","uri":"/LinkedList/"},{"categories":["Algorithm"],"content":"插入操作与指针丢失 由于链表的特性，插入删除操作只需要找到对应节点直接插入即可，所以时间复杂度是O（1）；下面通过例子演示下插入操作： 如图，将在 23节点和12节点间插入14节点： [image:708D7997-7D7E-4CD5-9E2D-4B942D4718A0-313-0001C97522ACFEA9/linkedlist2png.png] x.next = cur.next; // 将 x 的结点的 next 指针指向下一结点； cur.next = x; // 将 cur 的 next 指针指向 x 结点； 实现插入、删除的过程需要注意赋值操作顺序。 我在做题的过程中，经常会想当然的先将当前节点和下一节点的连结断开，即cur.next指针指向x节点。再去关联x的后继节点。 若是像上面这样，将两句调换顺序则会指针丢失，导致断链。 ","date":"2019-05-15","objectID":"/LinkedList/:0:2","tags":["算法"],"title":"LinkedList","uri":"/LinkedList/"},{"categories":["Algorithm"],"content":"哨兵节点 上面提到头节点和尾节点有着不同的特性，因而在实现插入、删除操作的时候，需要格外进行处理，这样代码实现会繁琐许多。 这里将引入哨兵节点的概念，哨兵就像标识牌一样作为一个标志，如链表结构图中的head节点，该节点不直接参与业务，只是标记位置。 head节点一般不存储数据；当其作为一个标志位存在时，插入第一个节点和删除最后一个节点都可以复用同一代码逻辑。 ","date":"2019-05-15","objectID":"/LinkedList/:0:3","tags":["算法"],"title":"LinkedList","uri":"/LinkedList/"},{"categories":["Algorithm"],"content":"边界条件 代码实现过程中，总会碰到一些边界或是极端情况，这时候没有写边界条件，迎来的往往是雪崩。 之前做题就遇到过，由于未判定尾节点的情况，导致断链。做题的时候，最好列一下check list： 链表为空 只包含头节点或尾节点 处理尾节点逻辑 赋值顺序 链表合并 上面只是笼统的举例，具体还是得看题，想想极端情况下代码是否能运行；最好画下图解，方便记忆。 ","date":"2019-05-15","objectID":"/LinkedList/:0:4","tags":["算法"],"title":"LinkedList","uri":"/LinkedList/"},{"categories":["Life"],"content":"闲适少绪 午后闲暇无事，寻一处阴凉地界，伏坐树下。举目四眺，偶摘一叶，方觉“一叶障目”并非妄言。 抬手观之，其叶碧华如玉，温润柔滑，明晰净透。根分三茎，主茎自下贯穿，次从以环合主茎，丝络连绵不绝，晰之若晶莹剔透。上倚玄青天幕，娉婷立于云巅，仿佛兮若婀娜神女，玉貌韶年，冰肌雪脂，环腰如素，霞云似裙带飘舞飞扬，仿若流逸倩女欲乘风而去。横置远望，形若骄阳升朝霞；迫而察之，颜如芙蕖出渌波。 悠悠间，忽现昨日烟云变幻。昨时缥缈云雾，形状诡谲，无不巧然形物，惟妙惟肖。云幕之中，或虎踞龙盘，或厉鬼英魂，或楼阁亭台，间又以流云铺漫青岩，黑石中缀如鸟，若行于其间俯仰皆得，恍恍然如历异世焉。 清风入耳，往昔如烟过。听闻水声，却是鱼儿浮游远逝。翛然而来，悠忽而去，好不自在。凭拦坐望，清幽寒池，山风徐徐，日映华水，粼粼波光，好似月光碎片。忽念往日垂钓，得锦鲤，开合唇间，鬓须长扬，犹若龙象。莫非鱼龙之说有据？哈，何故多虑。捻叶作舟，借风东去，逐碧波，卧龙侧，悉凭天意。 Tips 回首晴天，双燕排云上。 日晕澄潭，未知虬龙卧。 随意遐想，却昏昏睡去。 日暮时分，丹霞万顷，上下天光，气接云空，如梦似幻。所处虽非峰峦叠翠，横巘联岚，却也绿树深山，飞瀑流泉，别是一番风味。待到暮色渐深，蝙蝠伏匿，寻夜食。常言蝠蛇其心，又闻嗜血性诡，多变常式，人多惧怕。然善观之，其行不由足，飞不假翼，夜捕蚊虫食之。池间多蚊虫，甚合我意，常观其行。 夜半钟声到客船，此时无声胜有声。昨夜月明如灯火皎辉，隐了星迹，直言月明星稀，浮华万千，乡里安得旧颜？今夜另寻他处，上得楼台，不见月华，却是偶得繁星一片。瑰丽之景暂按不表，踱至明处，方见阁楼檐角，旁悬玉盘，岂非明月？善。道是“不识庐山真面目，只缘身在此山中”。 月上中天，贪看数眼，依日前所想，聊作此篇。闲情逸致也。 ","date":"2015-08-01","objectID":"/confus/:0:0","tags":["生活","随笔"],"title":"闲适少绪","uri":"/confus/"}]