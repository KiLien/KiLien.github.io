<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Leetcode - 标签 - Kilien's Blog</title><link>http://KiLien.github.io/tags/leetcode/</link><description>Leetcode - 标签 - Kilien's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>ki.lien@foxmail.com (Kilien)</managingEditor><webMaster>ki.lien@foxmail.com (Kilien)</webMaster><lastBuildDate>Tue, 10 Nov 2020 11:06:17 +0800</lastBuildDate><atom:link href="http://KiLien.github.io/tags/leetcode/" rel="self" type="application/rss+xml"/><item><title>LeetCode-160-相交链表</title><link>http://KiLien.github.io/leetcode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</link><pubDate>Tue, 10 Nov 2020 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/leetcode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</guid><description>LeetCode-160相交链表 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表**：** 相交链表" 相交链表 在节点 c1 开始相交。 示</description></item><item><title>LeetCode-24-两两交换链表中的节点</title><link>http://KiLien.github.io/swapnodesinpairs/</link><pubDate>Wed, 29 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/swapnodesinpairs/</guid><description><![CDATA[Swap Nodes in Pairs Leetcode 24.Swap Nodes in Pairs Given alinked list, swap every two adjacent nodes and return its head. You maynotmodify the values in the list’s nodes, only nodes itself may be changed. Example: Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #Author:kilien]]></description></item><item><title>LeetCode-141-环形链表</title><link>http://KiLien.github.io/linkedlistcycle/</link><pubDate>Mon, 27 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/linkedlistcycle/</guid><description>Linked List Cycle Leetcode 141.Linked List Cycle Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integerposwhich represents the position (0-indexed)in the linked list where tail connects to. Ifposis-1, then there is no cycle in the linked list. Example : Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in</description></item><item><title>LeetCode-148-排序链表</title><link>http://KiLien.github.io/sortlist/</link><pubDate>Mon, 27 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/sortlist/</guid><description><![CDATA[Sort List LeetCode 148.Sort List Sort a linked list inO(nlogn) time using constant space complexity. Example 1: Input: 4-&gt;2-&gt;1-&gt;3 Output: 1-&gt;2-&gt;3-&gt;4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # Author：kilien # 思路]]></description></item><item><title>LeetCode-206-反转链表</title><link>http://KiLien.github.io/reverselinkedlist/</link><pubDate>Sat, 25 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/reverselinkedlist/</guid><description>Reverse Linked List Leetcode 206.Reverse Linked List 链表本质是理解“指针”的概念。指针在各种语言都有运用到，只是叫法不同，就像Java中是“引用”。实际上，意思都是存储对象的内存</description></item><item><title>LeetCode-322-零钱兑换</title><link>http://KiLien.github.io/coinchange/</link><pubDate>Thu, 23 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/coinchange/</guid><description>LeetCode 322 零钱兑换 题目： 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组</description></item><item><title>ImplementStackusingQueues</title><link>http://KiLien.github.io/implementstackusingqueues/</link><pubDate>Tue, 21 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/implementstackusingqueues/</guid><description>Implement Stack using Queues Leetcode 225. Implement Stack using Queues Implement the following operations of a stack using queues. push(x) — Push element x onto stack. pop() — Removes the element on top of the stack. top() — Get the top element. empty() — Return whether the stack is empty. Example: 1 2 3 4 5 6 7 8 MyStack stack = new MyStack(); stack.push(1); stack.push(2); stack.top(); // returns 2</description></item><item><title>LeetCode-232-用栈实现队列</title><link>http://KiLien.github.io/implementqueueusingstacks/</link><pubDate>Tue, 21 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/implementqueueusingstacks/</guid><description>Implement Queue using Stacks Leetcode 232.Implement Queue using Stacks Implement the following operations of a queue using stacks. push(x) — Push element x to the back of queue. pop() — Removes the element from in front of queue. peek() — Get the front element. empty() — Return whether the queue is empty. Example: 1 2 3 4 5 6 7 MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // returns</description></item><item><title>LeetCode-20-有效括号</title><link>http://KiLien.github.io/validparentheses/</link><pubDate>Mon, 20 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/validparentheses/</guid><description>Valid Parentheses Leetcode 20.Valid Parentheses Given a string containing just the characters’(‘,’)’,’{‘,’}’,’[‘and’]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of</description></item><item><title>LeetCode-242-有效的字母异位词</title><link>http://KiLien.github.io/vaildanagram/</link><pubDate>Mon, 20 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/vaildanagram/</guid><description>Valid Anagram Leetcode 242.Valid Anagram Given two strings s and t , write a function to determine if t is an anagram of s. 1 2 3 4 5 6 Example： Input: s = “anagram”, t = “nagaram” Output: true Input: s = “ra</description></item></channel></rss>