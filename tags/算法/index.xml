<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>算法 - 标签 - Kilien's Blog</title><link>http://KiLien.github.io/tags/%E7%AE%97%E6%B3%95/</link><description>算法 - 标签 - Kilien's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>ki.lien@foxmail.com (Kilien)</managingEditor><webMaster>ki.lien@foxmail.com (Kilien)</webMaster><lastBuildDate>Tue, 10 Nov 2020 11:06:17 +0800</lastBuildDate><atom:link href="http://KiLien.github.io/tags/%E7%AE%97%E6%B3%95/" rel="self" type="application/rss+xml"/><item><title>LeetCode-160-相交链表</title><link>http://KiLien.github.io/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</link><pubDate>Tue, 10 Nov 2020 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</guid><description>LeetCode-160相交链表 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表**：** 相交链表" 相交链表 在节点 c1 开始相交。 示</description></item><item><title>LeetCode-821-字符的最短距离</title><link>http://KiLien.github.io/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</link><pubDate>Mon, 02 Nov 2020 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</guid><description>LeetCode-821-字符的最短距离 题目 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组</description></item><item><title>LeetCode-66-加一</title><link>http://KiLien.github.io/LeetCode-66-%E5%8A%A0%E4%B8%80/</link><pubDate>Sun, 01 Nov 2020 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/LeetCode-66-%E5%8A%A0%E4%B8%80/</guid><description>LeetCode-66 加一 题目 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以</description></item><item><title>LeetCode-24-两两交换链表中的节点</title><link>http://KiLien.github.io/SwapNodesinPairs/</link><pubDate>Wed, 29 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/SwapNodesinPairs/</guid><description><![CDATA[Swap Nodes in Pairs Leetcode 24.Swap Nodes in Pairs Given alinked list, swap every two adjacent nodes and return its head. You maynotmodify the values in the list’s nodes, only nodes itself may be changed. Example: Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #Author:kilien]]></description></item><item><title>LeetCode-141-环形链表</title><link>http://KiLien.github.io/LinkedListCycle/</link><pubDate>Mon, 27 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/LinkedListCycle/</guid><description>Linked List Cycle Leetcode 141.Linked List Cycle Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integerposwhich represents the position (0-indexed)in the linked list where tail connects to. Ifposis-1, then there is no cycle in the linked list. Example : Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in</description></item><item><title>LeetCode-148-排序链表</title><link>http://KiLien.github.io/SortList/</link><pubDate>Mon, 27 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/SortList/</guid><description><![CDATA[Sort List LeetCode 148.Sort List Sort a linked list inO(nlogn) time using constant space complexity. Example 1: Input: 4-&gt;2-&gt;1-&gt;3 Output: 1-&gt;2-&gt;3-&gt;4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # Author：kilien # 思路]]></description></item><item><title>LeetCode-206-反转链表</title><link>http://KiLien.github.io/reverseLinkedList/</link><pubDate>Sat, 25 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/reverseLinkedList/</guid><description>Reverse Linked List Leetcode 206.Reverse Linked List 链表本质是理解“指针”的概念。指针在各种语言都有运用到，只是叫法不同，就像Java中是“引用”。实际上，意思都是存储对象的内存</description></item><item><title>LeetCode-322-零钱兑换</title><link>http://KiLien.github.io/CoinChange/</link><pubDate>Thu, 23 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/CoinChange/</guid><description>LeetCode 322 零钱兑换 题目： 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组</description></item><item><title>ImplementStackusingQueues</title><link>http://KiLien.github.io/ImplementStackusingQueues/</link><pubDate>Tue, 21 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/ImplementStackusingQueues/</guid><description>Implement Stack using Queues Leetcode 225. Implement Stack using Queues Implement the following operations of a stack using queues. push(x) — Push element x onto stack. pop() — Removes the element on top of the stack. top() — Get the top element. empty() — Return whether the stack is empty. Example: 1 2 3 4 5 6 7 8 MyStack stack = new MyStack(); stack.push(1); stack.push(2); stack.top(); // returns 2</description></item><item><title>LeetCode-232-用栈实现队列</title><link>http://KiLien.github.io/ImplementQueueusingStacks/</link><pubDate>Tue, 21 May 2019 11:06:17 +0800</pubDate><author>作者</author><guid>http://KiLien.github.io/ImplementQueueusingStacks/</guid><description>Implement Queue using Stacks Leetcode 232.Implement Queue using Stacks Implement the following operations of a queue using stacks. push(x) — Push element x to the back of queue. pop() — Removes the element from in front of queue. peek() — Get the front element. empty() — Return whether the queue is empty. Example: 1 2 3 4 5 6 7 MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // returns</description></item></channel></rss>